1
00:00:13,120 --> 00:00:15,679
yeah sorry about that we had some

2
00:00:15,679 --> 00:00:18,520
glitches in The

3
00:00:20,760 --> 00:00:23,909
[Music]

4
00:00:24,000 --> 00:00:28,320
Matrix all you need

5
00:00:33,200 --> 00:00:37,000
uh okay you're not muted anymore yeah

6
00:00:37,000 --> 00:00:40,120
should be fine

7
00:00:49,320 --> 00:00:52,039
yeah that's

8
00:00:52,039 --> 00:00:55,359
better all right yes where was I so why

9
00:00:55,359 --> 00:00:58,480
is this important so you categor

10
00:00:58,480 --> 00:01:00,600
categorically no longer have memory

11
00:01:00,600 --> 00:01:02,680
Leakes caused by forgetting to

12
00:01:02,680 --> 00:01:04,040
reallocate

13
00:01:04,040 --> 00:01:07,280
Something in any logical branch of your

14
00:01:07,280 --> 00:01:10,280
code

15
00:01:52,360 --> 00:01:56,360
dude you oh yeah see

16
00:02:10,199 --> 00:02:12,720
no I'm not

17
00:02:13,080 --> 00:02:16,080
muted

18
00:02:19,080 --> 00:02:23,360
well all kinds of fiddling

19
00:02:25,959 --> 00:02:29,360
here but yeah so you won't have memory

20
00:02:29,360 --> 00:02:31,280
leags because you forget to deallocate

21
00:02:31,280 --> 00:02:33,400
you don't leak file handles because you

22
00:02:33,400 --> 00:02:37,200
forget to close a file this tends to

23
00:02:37,200 --> 00:02:40,280
still happen surprisingly often for Java

24
00:02:40,280 --> 00:02:42,920
programmers where they kind of over rely

25
00:02:42,920 --> 00:02:46,280
on a garbage collector to to General

26
00:02:46,280 --> 00:02:48,680
cleanup which it can't

27
00:02:48,680 --> 00:02:51,840
do and you just won't have Deadlocks

28
00:02:51,840 --> 00:02:54,560
caused by forgetting to unlock a lock or

29
00:02:54,560 --> 00:02:59,120
a newex that kind of problems are just

30
00:02:59,120 --> 00:03:00,879
categorically

31
00:03:00,879 --> 00:03:04,799
gone but I do need to emphasize that

32
00:03:04,799 --> 00:03:08,360
that applies to the types of pro pro

33
00:03:08,360 --> 00:03:10,040
problems that would be

34
00:03:10,040 --> 00:03:13,239
caused by forgetting to do

35
00:03:13,239 --> 00:03:15,920
cleanup this kind of resource management

36
00:03:15,920 --> 00:03:17,799
rappers won't magically make your

37
00:03:17,799 --> 00:03:20,120
programs bug free you can still

38
00:03:20,120 --> 00:03:23,280
have memory management problems and even

39
00:03:23,280 --> 00:03:25,920
Deadlocks um if you

40
00:03:25,920 --> 00:03:29,080
have suitable kinds of circularities in

41
00:03:29,080 --> 00:03:30,560
your code

42
00:03:30,560 --> 00:03:33,519
but uh certain kinds of bugs are just

43
00:03:33,519 --> 00:03:36,640
categorically no longer there which of

44
00:03:36,640 --> 00:03:39,000
course in an engineering setting saves

45
00:03:39,000 --> 00:03:42,319
you time to do something more

46
00:03:42,319 --> 00:03:46,599
useful so if we look at some

47
00:03:46,599 --> 00:03:50,760
examples that appear in the standard

48
00:03:50,760 --> 00:03:55,000
Library uh I did notice that there's a

49
00:03:55,000 --> 00:03:58,319
whole bunch of exercises in this course

50
00:03:58,319 --> 00:04:02,000
where you allocate uh Legacy arrays C

51
00:04:02,000 --> 00:04:03,720
style arrays

52
00:04:03,720 --> 00:04:07,000
dynamically I don't recall when I have

53
00:04:07,000 --> 00:04:10,079
done that the last time because the

54
00:04:10,079 --> 00:04:15,120
vector does it just fine it uh wraps a

55
00:04:15,120 --> 00:04:16,918
dynamically allocated

56
00:04:16,918 --> 00:04:21,478
array and automates it its cleanup uh

57
00:04:21,478 --> 00:04:23,479
and it of course also automates the

58
00:04:23,479 --> 00:04:25,960
clean up of the array

59
00:04:25,960 --> 00:04:28,800
elements so just in case they would

60
00:04:28,800 --> 00:04:31,560
actually be Resource Management handles

61
00:04:31,560 --> 00:04:35,160
or wrappers those resources would be

62
00:04:35,160 --> 00:04:38,280
cleaned up automatically

63
00:04:38,280 --> 00:04:41,240
recursively so when when you destroy a

64
00:04:41,240 --> 00:04:43,560
vector it of course gets rid of the

65
00:04:43,560 --> 00:04:44,960
actual

66
00:04:44,960 --> 00:04:48,080
array but before that it will destroy

67
00:04:48,080 --> 00:04:50,600
every element in case they have

68
00:04:50,600 --> 00:04:52,039
non-trivial

69
00:04:52,039 --> 00:04:54,880
cleanup so it will call the distructor

70
00:04:54,880 --> 00:04:57,440
of every element and then get rid of the

71
00:04:57,440 --> 00:05:00,199
actual Ray

72
00:05:00,199 --> 00:05:03,360
Vector also very conveniently uh

73
00:05:03,360 --> 00:05:05,680
reallocates the array when

74
00:05:05,680 --> 00:05:08,919
necessary uh so in case you need to grow

75
00:05:08,919 --> 00:05:12,000
a vector you can you can do that

76
00:05:12,000 --> 00:05:14,240
automatically without without managing

77
00:05:14,240 --> 00:05:17,639
it yourself at all the old array is

78
00:05:17,639 --> 00:05:20,360
automatically cleaned up the new new

79
00:05:20,360 --> 00:05:23,280
array gets populated with the old

80
00:05:23,280 --> 00:05:25,840
elements and then later on when you

81
00:05:25,840 --> 00:05:28,400
finally destroy the vector it will just

82
00:05:28,400 --> 00:05:31,360
uh destroy the whatever array it

83
00:05:31,360 --> 00:05:33,880
currently

84
00:05:33,880 --> 00:05:37,240
has it's it's occasionally very

85
00:05:37,240 --> 00:05:40,280
convenient that you can you can handle

86
00:05:40,280 --> 00:05:43,120
vectors like they are by value types you

87
00:05:43,120 --> 00:05:45,160
can copy them you can move

88
00:05:45,160 --> 00:05:50,560
them it's uh much less regular regular

89
00:05:50,560 --> 00:05:54,680
to do that with a sear array you can't

90
00:05:54,680 --> 00:05:57,199
even really copy them except if you wrap

91
00:05:57,199 --> 00:06:01,240
them into a stru type

92
00:06:02,639 --> 00:06:05,199
so moving right

93
00:06:05,199 --> 00:06:08,720
along unique pointer is a unique

94
00:06:08,720 --> 00:06:11,800
ownership smart pointer that owns and

95
00:06:11,800 --> 00:06:15,120
destroys a dynamically allocated

96
00:06:15,120 --> 00:06:17,960
object it doesn't actually allocate that

97
00:06:17,960 --> 00:06:21,080
object but they it can wrap a pointer

98
00:06:21,080 --> 00:06:25,720
and there's a very par uh Factory

99
00:06:25,720 --> 00:06:30,039
function that gives you a unique point

100
00:06:30,039 --> 00:06:33,120
pointing to a dynamically allocated

101
00:06:33,120 --> 00:06:36,120
object that's the make unique

102
00:06:36,120 --> 00:06:37,639
there

103
00:06:37,639 --> 00:06:41,199
so make uh unique pointer when it goes

104
00:06:41,199 --> 00:06:42,400
out of

105
00:06:42,400 --> 00:06:46,479
scope it uh destroys the actual object

106
00:06:46,479 --> 00:06:49,720
pointed to to and then deallocates the

107
00:06:49,720 --> 00:06:54,759
memory so when we do that uh uh

108
00:06:54,759 --> 00:06:58,240
invocation of make unique there we get a

109
00:06:58,240 --> 00:07:00,879
unique pointer back that will own the

110
00:07:00,879 --> 00:07:03,120
actual D

111
00:07:03,120 --> 00:07:06,960
object and this works as a as a

112
00:07:06,960 --> 00:07:10,160
polymorphic pointer type as well because

113
00:07:10,160 --> 00:07:12,639
in this example our base class has a

114
00:07:12,639 --> 00:07:14,039
virtual

115
00:07:14,039 --> 00:07:19,160
Destructor so when we create an actual

116
00:07:19,160 --> 00:07:20,919
unique pointer to

117
00:07:20,919 --> 00:07:23,720
D we can convert that to a unique

118
00:07:23,720 --> 00:07:25,000
pointer of

119
00:07:25,000 --> 00:07:27,800
B and the destruction will do the right

120
00:07:27,800 --> 00:07:30,199
thing because it will just uh

121
00:07:30,199 --> 00:07:32,800
invoke the virtual Destructor on a

122
00:07:32,800 --> 00:07:36,840
pointer of of type pointer to B so it

123
00:07:36,840 --> 00:07:39,680
will clean up the D object correctly and

124
00:07:39,680 --> 00:07:42,599
do the uh releasing of the memory

125
00:07:42,599 --> 00:07:45,280
correctly as

126
00:07:45,879 --> 00:07:49,479
well I'm not going to teach you move

127
00:07:49,479 --> 00:07:51,599
semantics in this lecture it's one of

128
00:07:51,599 --> 00:07:52,400
the

129
00:07:52,400 --> 00:07:57,159
major uh parts of C++ 11 I'm just going

130
00:07:57,159 --> 00:07:59,720
to briefly mention that unique point is

131
00:07:59,720 --> 00:08:04,639
a move only type so you can't have two

132
00:08:04,639 --> 00:08:08,400
copies of it at least easily created

133
00:08:08,400 --> 00:08:11,319
that point to the same object that would

134
00:08:11,319 --> 00:08:13,800
be something that would defeat the

135
00:08:13,800 --> 00:08:16,240
purpose because you wouldn't know where

136
00:08:16,240 --> 00:08:17,879
where to do the

137
00:08:17,879 --> 00:08:21,960
cleanup that's why it has unique

138
00:08:21,960 --> 00:08:24,599
ownership and uh if you want to pass it

139
00:08:24,599 --> 00:08:28,919
by value like to the function f here you

140
00:08:28,919 --> 00:08:35,079
actually need to um invoke that uh St

141
00:08:35,399 --> 00:08:38,839
move don't want to highlight but yeah

142
00:08:38,839 --> 00:08:42,479
the call call of f needs to have that St

143
00:08:42,479 --> 00:08:43,559
move

144
00:08:43,559 --> 00:08:46,839
invocation what that will actually do is

145
00:08:46,839 --> 00:08:50,560
that uh it's going to pass the pass the

146
00:08:50,560 --> 00:08:54,680
unit pointer by value to F and in the

147
00:08:54,680 --> 00:08:58,399
scope of G the unique pointer that

148
00:08:58,399 --> 00:09:01,720
remains there and until the scope exit

149
00:09:01,720 --> 00:09:04,079
is going to be empty it's not going to

150
00:09:04,079 --> 00:09:07,440
point to anything that ownership is

151
00:09:07,440 --> 00:09:11,320
transferred by the move operation to the

152
00:09:11,320 --> 00:09:13,200
block scope of

153
00:09:13,200 --> 00:09:17,800
f where it's it's it's the uh the

154
00:09:17,800 --> 00:09:20,920
ownership passes to the parameter of

155
00:09:20,920 --> 00:09:21,959
function

156
00:09:21,959 --> 00:09:25,240
f which in practice means that when you

157
00:09:25,240 --> 00:09:27,920
return out of f or Escape out of it in

158
00:09:27,920 --> 00:09:32,640
any way then that uh object will be

159
00:09:33,880 --> 00:09:36,000
destroyed we have a different

160
00:09:36,000 --> 00:09:39,240
standardized smart pointer called share

161
00:09:39,240 --> 00:09:41,880
pointer this one is a reference counted

162
00:09:41,880 --> 00:09:45,560
smart pointer so for this particular

163
00:09:45,560 --> 00:09:48,680
smart pointer you can have multiple

164
00:09:48,680 --> 00:09:51,240
copies those copies don't copy the

165
00:09:51,240 --> 00:09:55,160
actual object pointed to it's uh

166
00:09:55,160 --> 00:09:57,800
multiple copies point to the same object

167
00:09:57,800 --> 00:10:00,680
that's dynamically allocated

168
00:10:00,680 --> 00:10:03,760
and then when you get rid of the last

169
00:10:03,760 --> 00:10:06,120
copy that at that point the reference

170
00:10:06,120 --> 00:10:08,839
count drops to zero and the actual

171
00:10:08,839 --> 00:10:10,320
cleanup

172
00:10:10,320 --> 00:10:14,120
happens there's some Curious properties

173
00:10:14,120 --> 00:10:17,800
that uh SHP pointer has

174
00:10:17,800 --> 00:10:20,760
because all that funny class hierarchy

175
00:10:20,760 --> 00:10:22,120
that we have

176
00:10:22,120 --> 00:10:26,760
there um so we have a base class it

177
00:10:26,760 --> 00:10:30,240
doesn't even have a virtual Destructor

178
00:10:30,240 --> 00:10:33,200
we inherit from that type to create our

179
00:10:33,200 --> 00:10:34,800
derive type

180
00:10:34,800 --> 00:10:39,920
B we can create a sharp pointer to

181
00:10:39,920 --> 00:10:44,079
D and uh actually assign it

182
00:10:44,079 --> 00:10:47,360
to to a share pointer of B by the way

183
00:10:47,360 --> 00:10:49,120
there's a bug in that slide that should

184
00:10:49,120 --> 00:10:51,959
be public inheritance the conversion

185
00:10:51,959 --> 00:10:54,440
doesn't actually work my bad I'll fix it

186
00:10:54,440 --> 00:10:57,200
when the slides get actually published

187
00:10:57,200 --> 00:10:59,800
but let's just just imagine that says

188
00:10:59,800 --> 00:11:02,760
class D colum public

189
00:11:02,760 --> 00:11:06,279
B so when that conversion is valid the

190
00:11:06,279 --> 00:11:08,279
conversion between those shared pointers

191
00:11:08,279 --> 00:11:11,240
is valid and then when you clean up a

192
00:11:11,240 --> 00:11:13,760
shared pointer of B that will actually

193
00:11:13,760 --> 00:11:16,480
destroy the D object

194
00:11:16,480 --> 00:11:19,440
correctly even though B doesn't have a

195
00:11:19,440 --> 00:11:21,079
virtual

196
00:11:21,079 --> 00:11:23,720
display that happens because when you

197
00:11:23,720 --> 00:11:26,880
create the uh share pointer of type

198
00:11:26,880 --> 00:11:30,279
D it will actually generate the cleanup

199
00:11:30,279 --> 00:11:32,120
code at that

200
00:11:32,120 --> 00:11:35,920
point and then it typ raises it which

201
00:11:35,920 --> 00:11:37,480
means that the

202
00:11:37,480 --> 00:11:41,360
uh sharp pointer doesn't really even

203
00:11:41,360 --> 00:11:43,480
know what kind of an object is it's

204
00:11:43,480 --> 00:11:44,680
pointing

205
00:11:44,680 --> 00:11:48,399
to so basically it has an internal block

206
00:11:48,399 --> 00:11:50,240
that has virtual

207
00:11:50,240 --> 00:11:53,079
Destructor and that that internal blocks

208
00:11:53,079 --> 00:11:56,040
virtual Destructor is called even if you

209
00:11:56,040 --> 00:11:59,800
assign it to a share pointer of B

210
00:11:59,800 --> 00:12:01,279
that's just going to check that the

211
00:12:01,279 --> 00:12:03,839
conversion is valid and then it's going

212
00:12:03,839 --> 00:12:07,040
to use the same uh cleanup block that's

213
00:12:07,040 --> 00:12:10,560
in the shade pointer

214
00:12:10,560 --> 00:12:13,480
of and then by

215
00:12:13,480 --> 00:12:16,120
extension it also means that you can

216
00:12:16,120 --> 00:12:17,620
create a share pointer of

217
00:12:17,620 --> 00:12:18,760
[Music]

218
00:12:18,760 --> 00:12:22,320
p and initialize a share pointer of void

219
00:12:22,320 --> 00:12:26,760
with it and that still cleans up the uh

220
00:12:26,760 --> 00:12:30,920
uh a typed object correctly and

221
00:12:30,920 --> 00:12:33,600
properly uh which is something that raw

222
00:12:33,600 --> 00:12:36,839
pointers can't do you can't do clean up

223
00:12:36,839 --> 00:12:40,240
through a void star but with a smart

224
00:12:40,240 --> 00:12:42,279
pointer like share pointer you you

225
00:12:42,279 --> 00:12:44,240
actually

226
00:12:44,240 --> 00:12:47,360
can so yeah share pointers can be copied

227
00:12:47,360 --> 00:12:50,560
and move moved copying simply incence

228
00:12:50,560 --> 00:12:51,720
the reference

229
00:12:51,720 --> 00:12:55,399
C which is splendidly useful in in

230
00:12:55,399 --> 00:12:56,880
certain

231
00:12:56,880 --> 00:13:00,120
scenarios in practice you may run into

232
00:13:00,120 --> 00:13:02,360
into problems where you don't really

233
00:13:02,360 --> 00:13:07,279
know know in your code what is the uh uh

234
00:13:07,279 --> 00:13:09,519
supposed single and don't be owning

235
00:13:09,519 --> 00:13:12,440
scope for for some

236
00:13:12,440 --> 00:13:16,000
object uh it comes up in multi threaded

237
00:13:16,000 --> 00:13:20,839
programming par amount so you you can't

238
00:13:20,839 --> 00:13:23,040
really tell which scope owns the object

239
00:13:23,040 --> 00:13:25,839
but you can have multiple share pointers

240
00:13:25,839 --> 00:13:28,880
pointing to the object and when the last

241
00:13:28,880 --> 00:13:32,040
one goes away then cleanup

242
00:13:32,040 --> 00:13:35,120
happens this is complemented by having a

243
00:13:35,120 --> 00:13:38,839
weak pointer that breaks ownership cycle

244
00:13:38,839 --> 00:13:42,920
so if you would have

245
00:13:42,920 --> 00:13:46,040
um cyclical ownership where shed

246
00:13:46,040 --> 00:13:48,920
pointers end up pointing to each other

247
00:13:48,920 --> 00:13:51,040
the reference counts would never get to

248
00:13:51,040 --> 00:13:54,000
zero and cleanup would never happen so

249
00:13:54,000 --> 00:13:55,839
with weak weak pointer you can break

250
00:13:55,839 --> 00:13:59,360
that kind of Cycles

251
00:14:00,480 --> 00:14:03,160
so this this

252
00:14:03,160 --> 00:14:05,639
particular composition example was

253
00:14:05,639 --> 00:14:09,199
strongly motivated by exercis is that

254
00:14:09,199 --> 00:14:11,759
create Dynamic arrays of dynamically

255
00:14:11,759 --> 00:14:13,199
allocated

256
00:14:13,199 --> 00:14:16,199
objects and at least in those slides

257
00:14:16,199 --> 00:14:19,320
they never showed how to clean that up

258
00:14:19,320 --> 00:14:23,440
because you would need to Loop over the

259
00:14:23,440 --> 00:14:26,639
array destroy the element uh free its

260
00:14:26,639 --> 00:14:27,839
memory

261
00:14:27,839 --> 00:14:30,720
allocation and then finally clean up the

262
00:14:30,720 --> 00:14:34,440
uh allocation for the array

263
00:14:34,440 --> 00:14:36,759
itself this happens completely

264
00:14:36,759 --> 00:14:38,800
automatically if you have a vector of

265
00:14:38,800 --> 00:14:42,839
unique poters so these um res Resource

266
00:14:42,839 --> 00:14:44,839
Management types

267
00:14:44,839 --> 00:14:48,320
compos so you you could have a vector of

268
00:14:48,320 --> 00:14:52,440
unique poter to be and then in whatever

269
00:14:52,440 --> 00:14:55,399
processing Loop

270
00:14:55,399 --> 00:14:59,720
create um Dynamic objects of type D

271
00:14:59,720 --> 00:15:02,000
push the SM pointers into the vector

272
00:15:02,000 --> 00:15:03,959
when when the vector is eventually

273
00:15:03,959 --> 00:15:08,079
cleaned up when it goes out of scope and

274
00:15:08,079 --> 00:15:10,880
then automatically

275
00:15:10,880 --> 00:15:13,279
destroyed every object behind those

276
00:15:13,279 --> 00:15:15,360
allocations is destroyed the memory

277
00:15:15,360 --> 00:15:18,040
allocated for every of element object is

278
00:15:18,040 --> 00:15:21,399
released and then the array inside the

279
00:15:21,399 --> 00:15:23,759
vector is the

280
00:15:23,759 --> 00:15:27,120
allocated so and you don't you don't

281
00:15:27,120 --> 00:15:29,120
need to

282
00:15:29,120 --> 00:15:32,319
write more complicated cleanup code just

283
00:15:32,319 --> 00:15:34,040
because you have a more complicated

284
00:15:34,040 --> 00:15:38,399
nested type it's just basically in

285
00:15:38,399 --> 00:15:43,199
invisible in your source code uh of of

286
00:15:43,199 --> 00:15:46,759
course it has complexity effects but uh

287
00:15:46,759 --> 00:15:50,279
for in the sense of programming it's no

288
00:15:50,279 --> 00:15:54,199
more complicated to have such a uh

289
00:15:54,199 --> 00:15:57,000
composition than just have a like a

290
00:15:57,000 --> 00:15:59,920
vector of plane in as as far as cleanup

291
00:15:59,920 --> 00:16:02,279
goes it's it's equally

292
00:16:02,279 --> 00:16:08,639
simple question is it the so um do we

293
00:16:08,639 --> 00:16:11,360
need unique pointers with vors in order

294
00:16:11,360 --> 00:16:12,399
to

295
00:16:12,399 --> 00:16:17,399
dealate or normal pointers are

296
00:16:23,560 --> 00:16:26,560
normal

297
00:16:26,959 --> 00:16:30,000
uh well

298
00:16:30,000 --> 00:16:32,160
yes you do if you want the whole cleanup

299
00:16:32,160 --> 00:16:33,560
to be

300
00:16:33,560 --> 00:16:37,920
automatic if you use R vectors of row

301
00:16:37,920 --> 00:16:40,519
pointers the cleanup of the vector

302
00:16:40,519 --> 00:16:43,440
doesn't destroy the objects pointed to

303
00:16:43,440 --> 00:16:44,639
by those

304
00:16:44,639 --> 00:16:47,800
pointers it would only get rid of the

305
00:16:47,800 --> 00:16:49,720
allocation in the vector for the

306
00:16:49,720 --> 00:16:51,600
pointers

307
00:16:51,600 --> 00:16:54,240
themselves of course that can sometimes

308
00:16:54,240 --> 00:16:57,120
be what you want but in case you

309
00:16:57,120 --> 00:17:01,120
actually have a container of dynamically

310
00:17:01,120 --> 00:17:04,799
allocated objects then in most most

311
00:17:04,799 --> 00:17:07,400
reasonable cases you want all of that to

312
00:17:07,400 --> 00:17:11,919
clean up so that's where you want to

313
00:17:11,919 --> 00:17:15,599
use a vector of unique poers if you have

314
00:17:15,599 --> 00:17:19,079
a vector of pointers that are not

315
00:17:19,079 --> 00:17:23,079
owning so that the uh actual objects not

316
00:17:23,079 --> 00:17:26,199
the pointers are managed elsewhere then

317
00:17:26,199 --> 00:17:30,199
you can use raw pointers

318
00:17:33,919 --> 00:17:37,679
I hope that answers the

319
00:17:38,679 --> 00:17:40,960
question all right

320
00:17:40,960 --> 00:17:45,280
so as I probably mentioned at some point

321
00:17:45,280 --> 00:17:48,880
this is not just about memory um it's

322
00:17:48,880 --> 00:17:52,039
more General than that so we have

323
00:17:52,039 --> 00:17:54,919
non-memory resources that work the same

324
00:17:54,919 --> 00:17:58,280
way you have these uh scoped handles to

325
00:17:58,280 --> 00:18:01,360
them you bind them to Local Scopes and

326
00:18:01,360 --> 00:18:03,559
uh do the cleanup on scope

327
00:18:03,559 --> 00:18:08,158
exit so for

328
00:18:08,360 --> 00:18:12,320
fstream it represents a file stream and

329
00:18:12,320 --> 00:18:14,600
uh does the closing of the file

330
00:18:14,600 --> 00:18:17,559
automatically in the destructor of f

331
00:18:17,559 --> 00:18:22,799
Stream So if I write that code using

332
00:18:22,799 --> 00:18:26,640
something like the C function f open and

333
00:18:26,640 --> 00:18:29,679
forget a corresponding F close I have

334
00:18:29,679 --> 00:18:32,679
now leaked a file descriptor and the

335
00:18:32,679 --> 00:18:33,679
file

336
00:18:33,679 --> 00:18:37,919
handle and uh in in in applications that

337
00:18:37,919 --> 00:18:40,280
run a long time the operating system

338
00:18:40,280 --> 00:18:43,200
will eventually fail your subsequent

339
00:18:43,200 --> 00:18:44,120
file

340
00:18:44,120 --> 00:18:46,320
operations because you have too many

341
00:18:46,320 --> 00:18:49,799
file Handles open in your process so it

342
00:18:49,799 --> 00:18:53,640
will start dysfunctioning over

343
00:18:53,640 --> 00:18:57,320
time but with with an with an fstream

344
00:18:57,320 --> 00:18:59,240
that uh cleanup is

345
00:18:59,240 --> 00:19:03,159
automatic we do that opening of the

346
00:19:03,159 --> 00:19:07,480
file and then right to it with the with

347
00:19:07,480 --> 00:19:10,159
the uh SoCal AR

348
00:19:10,159 --> 00:19:13,320
operator and then just exit the function

349
00:19:13,320 --> 00:19:17,399
and the the file is automatically

350
00:19:17,640 --> 00:19:21,960
closed we have H similar facilities for

351
00:19:21,960 --> 00:19:25,520
uh for locking and synchronization uh

352
00:19:25,520 --> 00:19:28,880
these are still lowlevel

353
00:19:28,880 --> 00:19:31,159
facilities for concurrency there's

354
00:19:31,159 --> 00:19:34,200
there's a whole bunch of higher level

355
00:19:34,200 --> 00:19:36,400
facilities for doing tradit programming

356
00:19:36,400 --> 00:19:38,360
but we're not going to go into those

357
00:19:38,360 --> 00:19:40,120
here

358
00:19:40,120 --> 00:19:42,799
so if you have a

359
00:19:42,799 --> 00:19:45,600
class that has an internal mutex that

360
00:19:45,600 --> 00:19:48,600
you need to do for thread

361
00:19:48,600 --> 00:19:51,919
synchronization uh in in member

362
00:19:51,919 --> 00:19:55,679
functions you can just uh wrap a Lo lock

363
00:19:55,679 --> 00:19:59,840
guard around the mutex

364
00:19:59,840 --> 00:20:02,640
that will lock lock the uh mutex in the

365
00:20:02,640 --> 00:20:05,360
Constructor of the loog guard and when

366
00:20:05,360 --> 00:20:07,640
the loog guard gets cleaned up and

367
00:20:07,640 --> 00:20:11,640
destroyed that will unlock the

368
00:20:12,039 --> 00:20:14,440
mutex there's

369
00:20:14,440 --> 00:20:18,080
a more flexible facility that does the

370
00:20:18,080 --> 00:20:21,400
same thing but it has uh additional

371
00:20:21,400 --> 00:20:25,799
Powers um a unique lock is not bound to

372
00:20:25,799 --> 00:20:29,520
a single scope so you can actually move

373
00:20:29,520 --> 00:20:31,840
it from one scope to another by passing

374
00:20:31,840 --> 00:20:34,480
it by value and moving

375
00:20:34,480 --> 00:20:37,880
it but it's it's useful to remember if

376
00:20:37,880 --> 00:20:40,320
you get into multi-threaded programming

377
00:20:40,320 --> 00:20:44,080
that while a resource wrapper like that

378
00:20:44,080 --> 00:20:47,720
can move from one scope to another

379
00:20:47,720 --> 00:20:51,440
mutexes can't mutexes and atomics tend

380
00:20:51,440 --> 00:20:53,120
to be immovable

381
00:20:53,120 --> 00:20:56,280
because of the way the actual locking

382
00:20:56,280 --> 00:20:59,240
happens they rely on the ad address of

383
00:20:59,240 --> 00:21:03,000
the object so there's certain limits

384
00:21:03,000 --> 00:21:06,320
what you can do with uh with types like

385
00:21:06,320 --> 00:21:08,919
this if if you have that kind of a class

386
00:21:08,919 --> 00:21:10,919
it's not going to be copyable because a

387
00:21:10,919 --> 00:21:13,919
new text can't be

388
00:21:14,279 --> 00:21:17,840
copied nor moved it's

389
00:21:17,840 --> 00:21:21,440
just an object that

390
00:21:21,440 --> 00:21:24,799
uh it's intrinsic property for the

391
00:21:24,799 --> 00:21:27,840
synchronization purposes is its address

392
00:21:27,840 --> 00:21:30,520
in memory

393
00:21:31,000 --> 00:21:34,279
I mean you can you can still copy object

394
00:21:34,279 --> 00:21:37,080
of objects of Type X but you need to

395
00:21:37,080 --> 00:21:39,159
write a custom copy Constructor to be

396
00:21:39,159 --> 00:21:42,039
able to do that so that it doesn't

397
00:21:42,039 --> 00:21:44,760
actually try to copy the source objects

398
00:21:44,760 --> 00:21:49,360
mutex but we'll just create a new m

399
00:21:49,440 --> 00:21:54,520
mutex j thread is a interesting

400
00:21:54,520 --> 00:21:58,679
Beast um it took a couple of years

401
00:21:58,679 --> 00:22:02,520
couple of quite quite a couple of years

402
00:22:02,520 --> 00:22:05,480
to come to agreement on uh on whether to

403
00:22:05,480 --> 00:22:07,480
standardize it at

404
00:22:07,480 --> 00:22:09,760
all

405
00:22:09,760 --> 00:22:12,760
so when you have

406
00:22:12,760 --> 00:22:15,080
um a thread

407
00:22:15,080 --> 00:22:19,000
handle and some code that

408
00:22:19,000 --> 00:22:22,559
operates uh on something else after that

409
00:22:22,559 --> 00:22:25,440
if if we imagine there's there's a whole

410
00:22:25,440 --> 00:22:27,080
lot of code after that fed

411
00:22:27,080 --> 00:22:28,960
initialization

412
00:22:28,960 --> 00:22:30,320
in function

413
00:22:30,320 --> 00:22:33,880
f you might end up exiting the function

414
00:22:33,880 --> 00:22:36,840
uh without ever joining the thread it

415
00:22:36,840 --> 00:22:39,760
requires that you join it so

416
00:22:39,760 --> 00:22:43,159
that the work doesn't get detached so

417
00:22:43,159 --> 00:22:46,279
you have to join a thread otherwise the

418
00:22:46,279 --> 00:22:48,000
program will

419
00:22:48,000 --> 00:22:52,640
terminate in case of a normal STD thread

420
00:22:52,640 --> 00:22:55,880
stdj thread does that joining

421
00:22:55,880 --> 00:22:58,720
automatically so

422
00:22:58,720 --> 00:23:01,159
if you're not sure whether you're

423
00:23:01,159 --> 00:23:04,400
returning in a similar way from all of

424
00:23:04,400 --> 00:23:07,480
your conditional

425
00:23:07,480 --> 00:23:10,720
branches excuse me and if you're not

426
00:23:10,720 --> 00:23:13,120
sure whether your code is throwing

427
00:23:13,120 --> 00:23:16,120
exception it might be a good idea to use

428
00:23:16,120 --> 00:23:17,679
use a joining

429
00:23:17,679 --> 00:23:21,200
thread because otherwise you would get

430
00:23:21,200 --> 00:23:23,640
termination if you escape that function

431
00:23:23,640 --> 00:23:26,200
in some way without joining the thread

432
00:23:26,200 --> 00:23:30,520
so St J thread does that in

433
00:23:30,520 --> 00:23:32,760
automatically which means that it will

434
00:23:32,760 --> 00:23:36,000
wait for the completion of the uh of the

435
00:23:36,000 --> 00:23:37,039
thread

436
00:23:37,039 --> 00:23:40,880
code which in turn means the U

437
00:23:40,880 --> 00:23:43,960
completion of that commented Su code

438
00:23:43,960 --> 00:23:47,400
here but it's it's a very F handy

439
00:23:47,400 --> 00:23:49,880
facility in the sense that you

440
00:23:49,880 --> 00:23:53,799
can you can program with threads in a

441
00:23:53,799 --> 00:23:55,440
exception safe

442
00:23:55,440 --> 00:23:59,919
manner or even as as I tend to call it

443
00:23:59,919 --> 00:24:02,679
safe manner because it you don't need to

444
00:24:02,679 --> 00:24:05,640
ensure that you invoke The Joint in all

445
00:24:05,640 --> 00:24:08,520
of your control

446
00:24:08,679 --> 00:24:12,200
path there is

447
00:24:12,200 --> 00:24:16,480
a very much generalized uh resource

448
00:24:16,480 --> 00:24:17,840
wrapper that

449
00:24:17,840 --> 00:24:21,679
is right now still in a technical

450
00:24:21,679 --> 00:24:25,279
specification which was a separate

451
00:24:25,279 --> 00:24:28,720
specification there were various uh

452
00:24:28,720 --> 00:24:30,240
specification

453
00:24:30,240 --> 00:24:33,640
problems with this type and it's the

454
00:24:33,640 --> 00:24:36,640
associated types called scope scope exit

455
00:24:36,640 --> 00:24:39,600
and scope clean if I remember

456
00:24:39,600 --> 00:24:43,000
correctly so those facilities were

457
00:24:43,000 --> 00:24:45,720
pushed into a separate technical

458
00:24:45,720 --> 00:24:48,320
specification and in implementations

459
00:24:48,320 --> 00:24:51,320
they have that experimental name space

460
00:24:51,320 --> 00:24:52,720
and the

461
00:24:52,720 --> 00:24:56,120
experimental prefix for the header

462
00:24:56,120 --> 00:24:59,640
use but nevertheless what this unique

463
00:24:59,640 --> 00:25:02,000
resource does is

464
00:25:02,000 --> 00:25:05,880
that I can just create it so that it

465
00:25:05,880 --> 00:25:08,720
wraps a reference to an

466
00:25:08,720 --> 00:25:12,039
INT and what and then I can register or

467
00:25:12,039 --> 00:25:14,880
clean up fun function for it uh that's

468
00:25:14,880 --> 00:25:18,039
the uh line that starts with the uh

469
00:25:18,039 --> 00:25:19,320
square

470
00:25:19,320 --> 00:25:22,679
brackets so what this cleanup ends up

471
00:25:22,679 --> 00:25:28,200
doing is that uh whatever you do to the

472
00:25:28,200 --> 00:25:28,840
uh

473
00:25:28,840 --> 00:25:33,919
value of I here set it to 42 set it to

474
00:25:33,919 --> 00:25:35,360
whatever

475
00:25:35,360 --> 00:25:37,760
values when the unique resource is

476
00:25:37,760 --> 00:25:40,679
destroyed it will reset it back to

477
00:25:40,679 --> 00:25:43,919
zero so this particular example has

478
00:25:43,919 --> 00:25:46,480
nothing to do with memory uh allocations

479
00:25:46,480 --> 00:25:48,600
or anything like that it has nothing to

480
00:25:48,600 --> 00:25:53,039
do with what you would usually call a

481
00:25:53,039 --> 00:25:57,799
resource it just returns program state

482
00:25:57,799 --> 00:26:01,399
to a particular State on cleanup which

483
00:26:01,399 --> 00:26:03,399
is very

484
00:26:03,399 --> 00:26:06,880
handy because if if you have complicated

485
00:26:06,880 --> 00:26:09,159
decision logic in that

486
00:26:09,159 --> 00:26:13,399
function uh it becomes unmanageable to

487
00:26:13,399 --> 00:26:16,320
figure out where in all places you would

488
00:26:16,320 --> 00:26:19,520
need to set the state back to what it

489
00:26:19,520 --> 00:26:22,399
was before you called the function but

490
00:26:22,399 --> 00:26:25,919
with a with a scope resource like this

491
00:26:25,919 --> 00:26:28,880
you can just do it so that it

492
00:26:28,880 --> 00:26:31,360
restores the original state in a

493
00:26:31,360 --> 00:26:34,840
Destructor which means you can't miss

494
00:26:34,840 --> 00:26:37,720
it question the

495
00:26:37,720 --> 00:26:40,000
resource what

496
00:26:40,000 --> 00:26:45,200
type because this this point too high or

497
00:26:45,200 --> 00:26:47,000
how that

498
00:26:47,000 --> 00:26:48,919
work

499
00:26:48,919 --> 00:26:50,880
start uh

500
00:26:50,880 --> 00:26:53,600
so the

501
00:26:53,600 --> 00:26:56,600
initialization of of the actual resource

502
00:26:56,600 --> 00:27:00,120
which is the first argument given to

503
00:27:00,120 --> 00:27:03,000
make unique resource checked is using

504
00:27:03,000 --> 00:27:06,640
that funny STD colon colon ref helper

505
00:27:06,640 --> 00:27:09,120
function which creates a reference

506
00:27:09,120 --> 00:27:12,760
wrapper of in that's why in the function

507
00:27:12,760 --> 00:27:16,000
body there the Lambda body I need to use

508
00:27:16,000 --> 00:27:19,520
uh the uh do get function because that's

509
00:27:19,520 --> 00:27:23,080
not an INT it's a reference wrapper of

510
00:27:23,080 --> 00:27:26,279
int another question maybe a bit serious

511
00:27:26,279 --> 00:27:30,159
but like why does get

512
00:27:34,960 --> 00:27:37,520
it would be read only if you have well

513
00:27:37,520 --> 00:27:38,240
let's

514
00:27:38,240 --> 00:27:42,399
see for a reference wrapper probably not

515
00:27:42,399 --> 00:27:44,279
because it's not deep

516
00:27:44,279 --> 00:27:48,559
const it's just a g function that

517
00:27:48,559 --> 00:27:51,519
Returns the U the underlying

518
00:27:51,519 --> 00:27:54,640
reference it maybe has an unfortunate

519
00:27:54,640 --> 00:27:56,480
name but there there is no set

520
00:27:56,480 --> 00:27:59,000
counterpart to it yeah all it does is

521
00:27:59,000 --> 00:28:01,120
that it Returns the

522
00:28:01,120 --> 00:28:03,799
reference you then assign the reference

523
00:28:03,799 --> 00:28:08,039
itself yeah you don't it's not it's not

524
00:28:08,039 --> 00:28:10,559
this is not resetting the reference

525
00:28:10,559 --> 00:28:13,840
inside the the reference rapper it's

526
00:28:13,840 --> 00:28:16,039
getting the actual reference and then

527
00:28:16,039 --> 00:28:18,640
assigning through that which means that

528
00:28:18,640 --> 00:28:25,279
we assign to the uh INT in The Wider

529
00:28:25,279 --> 00:28:29,600
scope this example would be far simpler

530
00:28:29,600 --> 00:28:32,960
and very Inc I hadn't tested this but I

531
00:28:32,960 --> 00:28:37,519
did so that's why it has those

532
00:28:37,600 --> 00:28:40,320
complexities I could have explicitly

533
00:28:40,320 --> 00:28:44,080
tried to create a uh unique resource

534
00:28:44,080 --> 00:28:46,880
that reps a reference to an in but I

535
00:28:46,880 --> 00:28:50,279
don't I don't think it supports that it

536
00:28:50,279 --> 00:28:52,279
probably requires a value

537
00:28:52,279 --> 00:28:55,440
type so a reference wrapper is a fake

538
00:28:55,440 --> 00:28:58,559
value type it turns a reference into a

539
00:28:58,559 --> 00:29:02,799
value type that's uh copyable it's even

540
00:29:02,799 --> 00:29:06,240
assignable even though you can't assign

541
00:29:06,240 --> 00:29:09,840
uh the core language references but you

542
00:29:09,840 --> 00:29:13,159
can actually assign a reference

543
00:29:13,159 --> 00:29:17,360
rapper but yeah we we

544
00:29:17,559 --> 00:29:20,559
really

545
00:29:22,399 --> 00:29:27,360
damage well deps what well yeah I mean

546
00:29:27,360 --> 00:29:29,559
it it could it can be a dangling

547
00:29:29,559 --> 00:29:32,840
reference that danger is always present

548
00:29:32,840 --> 00:29:35,559
in a language like this and until we fix

549
00:29:35,559 --> 00:29:38,679
it with some memory safety facilities in

550
00:29:38,679 --> 00:29:42,080
a couple of years hopefully that that

551
00:29:42,080 --> 00:29:44,320
remains to be seen how fast we can do it

552
00:29:44,320 --> 00:29:46,760
and how

553
00:29:47,120 --> 00:29:51,000
successful but yeah the point here is of

554
00:29:51,000 --> 00:29:54,559
course that you could turn pretty much

555
00:29:54,559 --> 00:29:59,000
anything into a resource with whatever

556
00:29:59,000 --> 00:30:00,200
kind of

557
00:30:00,200 --> 00:30:02,960
cleanup here we are just setting a

558
00:30:02,960 --> 00:30:05,279
particular value to an

559
00:30:05,279 --> 00:30:09,320
in and well ins are not common commonly

560
00:30:09,320 --> 00:30:12,000
thought of as a resources because they

561
00:30:12,000 --> 00:30:17,399
are just tags of bites that work work in

562
00:30:20,720 --> 00:30:24,640
arithmetic we have different kinds of

563
00:30:24,640 --> 00:30:28,720
U examples in the field

564
00:30:28,720 --> 00:30:32,960
that are that work in a similar vein

565
00:30:32,960 --> 00:30:37,279
so we have the uh CPN evaluated uh guard

566
00:30:37,279 --> 00:30:42,159
type of uh of GCC which is the uh new

567
00:30:42,159 --> 00:30:44,720
compiler there's a warning Sentinel in

568
00:30:44,720 --> 00:30:47,159
it I have an example of a q scope

569
00:30:47,159 --> 00:30:50,039
property update group not because I work

570
00:30:50,039 --> 00:30:53,120
at C but because it's it's just an

571
00:30:53,120 --> 00:30:57,279
intriguing example and then there's a

572
00:30:57,279 --> 00:30:59,840
rather important example of a

573
00:30:59,840 --> 00:31:03,039
transaction type in a database wrapping

574
00:31:03,039 --> 00:31:05,840
Library

575
00:31:05,840 --> 00:31:09,320
so this first thing uh the CP

576
00:31:09,320 --> 00:31:11,559
unevaluated this is this is really

577
00:31:11,559 --> 00:31:15,440
similar to the uh scope resource uh or

578
00:31:15,440 --> 00:31:18,760
the unique resource example because all

579
00:31:18,760 --> 00:31:21,519
all this type does is that it's fiddling

580
00:31:21,519 --> 00:31:23,679
with uh with

581
00:31:23,679 --> 00:31:26,960
INS What the compiler needs to do when

582
00:31:26,960 --> 00:31:30,200
compiling C+ code is that there are

583
00:31:30,200 --> 00:31:32,720
various situations where it runs into a

584
00:31:32,720 --> 00:31:35,039
context where the actual function calls

585
00:31:35,039 --> 00:31:37,919
are not evaluated the functions are not

586
00:31:37,919 --> 00:31:41,159
called you just do overload resolution

587
00:31:41,159 --> 00:31:44,080
and then look at types and look at the

588
00:31:44,080 --> 00:31:47,840
validity of things so it it happens to

589
00:31:47,840 --> 00:31:49,159
have

590
00:31:49,159 --> 00:31:53,159
these Global variables uh they

591
00:31:53,159 --> 00:31:58,120
are slightly scoped but not really

592
00:31:58,120 --> 00:32:01,399
and then in order to put it into that un

593
00:32:01,399 --> 00:32:04,880
evaluated Conex mode you need to

594
00:32:04,880 --> 00:32:08,200
increment these uh these configuration

595
00:32:08,200 --> 00:32:10,639
variables that tell the compiler what

596
00:32:10,639 --> 00:32:13,879
mode it it's

597
00:32:15,039 --> 00:32:18,559
in you can do that recursively uh when

598
00:32:18,559 --> 00:32:21,880
you happen to go into a nested context

599
00:32:21,880 --> 00:32:24,919
where you're still going to be

600
00:32:24,919 --> 00:32:27,919
unevaluated but it's it's looking at it

601
00:32:27,919 --> 00:32:30,240
a different function it doesn't

602
00:32:30,240 --> 00:32:33,840
necessarily know the calling Contex

603
00:32:33,840 --> 00:32:37,399
context so that's why it's done with a

604
00:32:37,399 --> 00:32:39,799
counter and then you have this

605
00:32:39,799 --> 00:32:42,519
automatically destroying uh or

606
00:32:42,519 --> 00:32:45,799
automatically cleaning up uh wrapper

607
00:32:45,799 --> 00:32:48,600
type where you just use

608
00:32:48,600 --> 00:32:53,480
a object of CP unevaluated type in your

609
00:32:53,480 --> 00:32:56,279
function and the automatic cleanup will

610
00:32:56,279 --> 00:32:59,440
undo its uh

611
00:32:59,440 --> 00:33:01,880
increment and then if you have this

612
00:33:01,880 --> 00:33:03,880
nested context where you have done this

613
00:33:03,880 --> 00:33:07,519
multiple times when you pop out of it it

614
00:33:07,519 --> 00:33:10,440
will uh restore the compiler back into

615
00:33:10,440 --> 00:33:14,399
the mode where it evaluates actual code

616
00:33:14,399 --> 00:33:17,320
meaning it generates function

617
00:33:17,320 --> 00:33:22,000
calls so this is another example of a

618
00:33:22,000 --> 00:33:24,600
resource wrapper that doesn't own

619
00:33:24,600 --> 00:33:28,200
anything those are ins they are not own

620
00:33:28,200 --> 00:33:31,440
owned by the type that it just uh

621
00:33:31,440 --> 00:33:33,519
increments and decrements a counter that

622
00:33:33,519 --> 00:33:38,200
this is massively useful because it it

623
00:33:38,200 --> 00:33:41,000
uh just turns certain kinds of logic

624
00:33:41,000 --> 00:33:45,159
errors off if you forget to decrement

625
00:33:45,159 --> 00:33:47,000
those counters when you're supposed to

626
00:33:47,000 --> 00:33:50,159
then your compiler is going to be in the

627
00:33:50,159 --> 00:33:52,240
unevaluated context when it's not

628
00:33:52,240 --> 00:33:56,000
supposed to be and it will misunderstand

629
00:33:56,000 --> 00:33:57,919
your program

630
00:33:57,919 --> 00:34:01,279
compilers in particular have very very

631
00:34:01,279 --> 00:34:05,519
hairy rats nness of of complicated

632
00:34:05,519 --> 00:34:08,040
conditions that are nested and

633
00:34:08,040 --> 00:34:11,359
recursive and all kinds of fun so it's

634
00:34:11,359 --> 00:34:14,560
very useful to have these sort of helper

635
00:34:14,560 --> 00:34:18,639
types there's a similar type that's used

636
00:34:18,639 --> 00:34:22,359
just for turning individual warnings of

637
00:34:22,359 --> 00:34:24,839
in the compiler there are certain

638
00:34:24,839 --> 00:34:27,719
cases where you need to compile code and

639
00:34:27,719 --> 00:34:30,320
regardless of what the user asked

640
00:34:30,320 --> 00:34:32,320
disable certain warnings because you

641
00:34:32,320 --> 00:34:34,440
know from the language context that

642
00:34:34,440 --> 00:34:38,000
those warnings would be false

643
00:34:38,000 --> 00:34:39,679
positive

644
00:34:39,679 --> 00:34:42,800
so there are these warning flags that

645
00:34:42,800 --> 00:34:47,359
compiler implements or uses and they

646
00:34:47,359 --> 00:34:50,359
are

647
00:34:51,079 --> 00:34:52,599
Global

648
00:34:52,599 --> 00:34:54,839
so what

649
00:34:54,839 --> 00:34:58,200
thisel does

650
00:34:58,200 --> 00:34:59,680
is

651
00:34:59,680 --> 00:35:02,839
that the

652
00:35:07,960 --> 00:35:13,040
echo it shouldn't be Me Maybe okay so

653
00:35:13,040 --> 00:35:15,599
what this warning senel does is that it

654
00:35:15,599 --> 00:35:18,280
wraps a reference to the actual flag

655
00:35:18,280 --> 00:35:19,160
which is

656
00:35:19,160 --> 00:35:23,640
a just a global in it's no no prettier

657
00:35:23,640 --> 00:35:26,720
than that that's how the compil was

658
00:35:26,720 --> 00:35:29,520
compiler was written in the prehistoric

659
00:35:29,520 --> 00:35:32,599
ages and hasn't been refactored

660
00:35:32,599 --> 00:35:36,640
since so the rapper wraps that Global in

661
00:35:36,640 --> 00:35:39,680
by using a reference so when you

662
00:35:39,680 --> 00:35:42,839
construct the warning Sentinel it uh it

663
00:35:42,839 --> 00:35:45,200
STS the reference to the

664
00:35:45,200 --> 00:35:50,760
flag and then um sets the warning flag

665
00:35:50,760 --> 00:35:53,040
off and then when you destroy the

666
00:35:53,040 --> 00:35:56,079
warning Sentinel it restores that

667
00:35:56,079 --> 00:35:59,359
warning flag to its original value so

668
00:35:59,359 --> 00:36:01,680
again this doesn't own an actual

669
00:36:01,680 --> 00:36:05,000
resource it's just manipulating ins but

670
00:36:05,000 --> 00:36:07,560
still very handy if you have complex

671
00:36:07,560 --> 00:36:10,240
complex logic and it's difficult to

672
00:36:10,240 --> 00:36:13,040
track where where your exiting block

673
00:36:13,040 --> 00:36:16,319
Scopes and uh returning from

674
00:36:16,319 --> 00:36:18,960
functions you can just rely on the

675
00:36:18,960 --> 00:36:21,040
destructor of the Sentinel to do the

676
00:36:21,040 --> 00:36:23,880
right thing it keeps

677
00:36:23,880 --> 00:36:27,599
your flag value balanced for a part

678
00:36:27,599 --> 00:36:31,160
particular scope so that you don't have

679
00:36:31,160 --> 00:36:34,960
unintended modification

680
00:36:35,119 --> 00:36:38,599
all this uh scope property update

681
00:36:38,599 --> 00:36:43,040
group is a fun example because all it

682
00:36:43,040 --> 00:36:46,160
does in its Constructor is that it calls

683
00:36:46,160 --> 00:36:49,040
that big in property update group

684
00:36:49,040 --> 00:36:51,839
function and in the destructor it calls

685
00:36:51,839 --> 00:36:55,079
an in property update group

686
00:36:55,079 --> 00:36:58,240
function so what those function do is

687
00:36:58,240 --> 00:37:00,920
that they basically um chunk property

688
00:37:00,920 --> 00:37:04,760
updates together so that they happen

689
00:37:04,760 --> 00:37:06,119
happen as a

690
00:37:06,119 --> 00:37:09,680
group and various notifications then

691
00:37:09,680 --> 00:37:12,040
notifications then behave

692
00:37:12,040 --> 00:37:15,079
differently but uh as far as the wrapper

693
00:37:15,079 --> 00:37:17,480
goes this is very simple in the sense

694
00:37:17,480 --> 00:37:19,480
that it just Begins the

695
00:37:19,480 --> 00:37:22,079
operation and ends the operation and

696
00:37:22,079 --> 00:37:24,119
since it's done in the destructure you

697
00:37:24,119 --> 00:37:28,040
can or get to do the uh end operation

698
00:37:28,040 --> 00:37:30,599
which you need to do otherwise you would

699
00:37:30,599 --> 00:37:31,680
kind

700
00:37:31,680 --> 00:37:38,240
of keep the a group operation uh ongoing

701
00:37:41,599 --> 00:37:45,000
forever because this is a this is a

702
00:37:45,000 --> 00:37:48,319
facility specific to cute properties and

703
00:37:48,319 --> 00:37:51,760
their their updates

704
00:37:51,760 --> 00:37:54,400
um I'm not sure whether there's really

705
00:37:54,400 --> 00:37:56,800
appetite for trying to standardize

706
00:37:56,800 --> 00:37:58,599
something like a C

707
00:37:58,599 --> 00:38:00,920
property there's been all kinds of

708
00:38:00,920 --> 00:38:05,640
discussions about that in in various uh

709
00:38:05,640 --> 00:38:09,599
audiences but for our purposes we uh

710
00:38:09,599 --> 00:38:14,200
created a new property type in order to

711
00:38:14,200 --> 00:38:16,720
make it easier to write uh write certain

712
00:38:16,720 --> 00:38:19,760
kinds of C++ code without without using

713
00:38:19,760 --> 00:38:23,240
our pre-processing facili facilities and

714
00:38:23,240 --> 00:38:29,439
all that so these are just really

715
00:38:29,480 --> 00:38:32,079
yeah these are very specific functions

716
00:38:32,079 --> 00:38:35,319
for very specific property

717
00:38:35,319 --> 00:38:39,240
types but the uh real gist of this

718
00:38:39,240 --> 00:38:43,480
particular example is that it it calls a

719
00:38:43,480 --> 00:38:45,839
particular operation that is then

720
00:38:45,839 --> 00:38:49,440
completed or closed in the distructor I

721
00:38:49,440 --> 00:38:52,640
mean the distructor closes the operation

722
00:38:52,640 --> 00:38:55,839
that's performed by The

723
00:38:56,280 --> 00:38:58,960
Constructor with which brings us to this

724
00:38:58,960 --> 00:39:01,560
example with it which is

725
00:39:01,560 --> 00:39:04,880
uh of massive

726
00:39:04,880 --> 00:39:09,240
significance so there is a database

727
00:39:09,240 --> 00:39:14,480
rapper Library called SQL PP meaning SQL

728
00:39:14,480 --> 00:39:18,119
C++ it has a transaction type that is a

729
00:39:18,119 --> 00:39:21,119
automatically cleaning up resource owner

730
00:39:21,119 --> 00:39:22,480
of

731
00:39:22,480 --> 00:39:25,400
sort meaning that when you create this

732
00:39:25,400 --> 00:39:28,119
transaction object it will open a

733
00:39:28,119 --> 00:39:30,240
transaction into the

734
00:39:30,240 --> 00:39:32,839
database all modifications that

735
00:39:32,839 --> 00:39:34,520
subsequently happen while this

736
00:39:34,520 --> 00:39:39,040
transaction is open will be bound to

737
00:39:39,040 --> 00:39:40,599
that

738
00:39:40,599 --> 00:39:42,960
transaction and then you can say that

739
00:39:42,960 --> 00:39:45,079
everything went fine and correctly and

740
00:39:45,079 --> 00:39:47,000
then you commit the transaction where

741
00:39:47,000 --> 00:39:49,520
all the modifications that you

742
00:39:49,520 --> 00:39:51,760
performed are actually done on the

743
00:39:51,760 --> 00:39:53,960
database so the database changes to

744
00:39:53,960 --> 00:39:59,359
reflect your U pending modification

745
00:39:59,359 --> 00:40:03,440
operations however if any sub operation

746
00:40:03,440 --> 00:40:06,200
fails and you decide to throw an

747
00:40:06,200 --> 00:40:09,720
exception out of your code or otherwise

748
00:40:09,720 --> 00:40:11,880
return from your block scope where you

749
00:40:11,880 --> 00:40:13,800
have this transaction

750
00:40:13,800 --> 00:40:17,800
object in those cases it will roll back

751
00:40:17,800 --> 00:40:20,319
the transaction which means that it will

752
00:40:20,319 --> 00:40:24,520
end up not modifying the database at

753
00:40:24,520 --> 00:40:28,119
all so if you think about real life

754
00:40:28,119 --> 00:40:32,119
examples like I will transfer €100 to

755
00:40:32,119 --> 00:40:35,119
you if there's some sort of problem in

756
00:40:35,119 --> 00:40:37,920
your receiving end that your account

757
00:40:37,920 --> 00:40:40,640
balance could not be updated to be in

758
00:40:40,640 --> 00:40:42,520
increased by

759
00:40:42,520 --> 00:40:45,359
€100 then it would be a rather good idea

760
00:40:45,359 --> 00:40:47,680
if uh if my account balance is not

761
00:40:47,680 --> 00:40:51,760
decreased either so that that money just

762
00:40:51,760 --> 00:40:55,079
didn't go into an abys and vanish into

763
00:40:55,079 --> 00:40:59,440
th air banks actually don't work quite

764
00:40:59,440 --> 00:41:01,640
that simply because they have account

765
00:41:01,640 --> 00:41:04,359
balance reservations and things like

766
00:41:04,359 --> 00:41:07,079
that but this sort of transactional

767
00:41:07,079 --> 00:41:09,839
operations are very important in all

768
00:41:09,839 --> 00:41:11,720
kinds of e-commerce and that sort of

769
00:41:11,720 --> 00:41:12,800
things and

770
00:41:12,800 --> 00:41:16,200
for ensuring data Integrity in general

771
00:41:16,200 --> 00:41:17,599
in various data

772
00:41:17,599 --> 00:41:19,720
source

773
00:41:19,720 --> 00:41:22,599
so mapping that into

774
00:41:22,599 --> 00:41:26,000
resource wrappers in C++ is fairly

775
00:41:26,000 --> 00:41:27,839
straightforward

776
00:41:27,839 --> 00:41:31,200
and it's kind of a natural onetoone

777
00:41:31,200 --> 00:41:35,400
mapping uh resource handling types are

778
00:41:35,400 --> 00:41:38,800
very much like transactions in that uh

779
00:41:38,800 --> 00:41:41,319
it's usually expected that they undo

780
00:41:41,319 --> 00:41:43,760
everything they did if at all

781
00:41:43,760 --> 00:41:48,040
possible if if if an error occurs if if

782
00:41:48,040 --> 00:41:51,280
you if you return from your block scope

783
00:41:51,280 --> 00:41:53,839
without going into the success

784
00:41:53,839 --> 00:41:56,839
completion

785
00:41:58,000 --> 00:42:02,640
which uh leads us to the second

786
00:42:02,640 --> 00:42:05,480
part which is the

787
00:42:05,480 --> 00:42:09,880
Ri so as I mentioned earlier it stands

788
00:42:09,880 --> 00:42:13,440
for resource acquisition is

789
00:42:13,440 --> 00:42:17,280
initialization it is a particular

790
00:42:17,280 --> 00:42:19,480
pattern where you use a resource

791
00:42:19,480 --> 00:42:22,839
management object that owns a

792
00:42:22,839 --> 00:42:26,440
resource and the tie in of those so to

793
00:42:26,440 --> 00:42:29,720
speak in is that the resource management

794
00:42:29,720 --> 00:42:33,000
object doesn't exist if acquiring the

795
00:42:33,000 --> 00:42:34,000
resource

796
00:42:34,000 --> 00:42:38,920
fail so it ties into z++

797
00:42:38,920 --> 00:42:41,119
exceptions

798
00:42:41,119 --> 00:42:44,119
because what what that means that whole

799
00:42:44,119 --> 00:42:46,000
resource acquisition is

800
00:42:46,000 --> 00:42:51,520
initialization is that uh a minute yeah

801
00:42:51,520 --> 00:42:54,079
so what we have is that we have the

802
00:42:54,079 --> 00:42:56,720
resource wrapper and its Constructor

803
00:42:56,720 --> 00:43:00,400
acquir the result for example allocates

804
00:43:00,400 --> 00:43:04,119
memory for an object and constructs an

805
00:43:04,119 --> 00:43:08,079
object and if that fails The Constructor

806
00:43:08,079 --> 00:43:09,960
throws an

807
00:43:09,960 --> 00:43:13,880
exception and the uh Resource Management

808
00:43:13,880 --> 00:43:15,960
rapper never

809
00:43:15,960 --> 00:43:18,240
existed and

810
00:43:18,240 --> 00:43:21,559
uh almost equally if not more

811
00:43:21,559 --> 00:43:24,359
importantly the code following that

812
00:43:24,359 --> 00:43:28,759
construction doesn't run

813
00:43:29,200 --> 00:43:32,880
then of course in the uh corresponding

814
00:43:32,880 --> 00:43:36,680
Destructor you release the resource

815
00:43:36,680 --> 00:43:39,559
so when we initialize an object we

816
00:43:39,559 --> 00:43:41,800
acquire the resource when we destroy an

817
00:43:41,800 --> 00:43:44,520
object we are We Are release the

818
00:43:44,520 --> 00:43:47,960
resource so it's bound to the uh

819
00:43:47,960 --> 00:43:50,640
Resource Management objects

820
00:43:50,640 --> 00:43:53,559
Lifetime and the particular resource

821
00:43:53,559 --> 00:43:55,880
that we are talking about doesn't exist

822
00:43:55,880 --> 00:43:59,520
outside of the uh of the rappers bytime

823
00:43:59,520 --> 00:44:02,319
they are bound

824
00:44:03,040 --> 00:44:06,040
together so yeah failing to acquire a

825
00:44:06,040 --> 00:44:07,880
resource is a failure to

826
00:44:07,880 --> 00:44:10,839
initialize the uh resource object uh

827
00:44:10,839 --> 00:44:13,559
never exists the rapper that reps it

828
00:44:13,559 --> 00:44:14,640
never

829
00:44:14,640 --> 00:44:17,920
exist and uh well the follow subsequent

830
00:44:17,920 --> 00:44:20,440
code is never run and the cleanup is

831
00:44:20,440 --> 00:44:22,520
never performed because there's no need

832
00:44:22,520 --> 00:44:24,200
for

833
00:44:24,200 --> 00:44:28,319
it so what we can do with

834
00:44:28,319 --> 00:44:31,599
this is that we can actually rely on

835
00:44:31,599 --> 00:44:34,280
that uh so-called

836
00:44:34,280 --> 00:44:38,400
invariant that a r type has a valid

837
00:44:38,400 --> 00:44:40,319
resource in

838
00:44:40,319 --> 00:44:44,040
it so when we do that make unique

839
00:44:44,040 --> 00:44:48,760
there and bind it to a con unique

840
00:44:48,760 --> 00:44:51,280
pointer we know that after that

841
00:44:51,280 --> 00:44:55,119
operation the unique pointer of

842
00:44:55,119 --> 00:44:58,319
B will have an OP object inside it

843
00:44:58,319 --> 00:45:00,480
otherwise make unique would have thrown

844
00:45:00,480 --> 00:45:01,599
an

845
00:45:01,599 --> 00:45:04,760
exception so we can just D reference

846
00:45:04,760 --> 00:45:07,400
that pointer in those subsequent two

847
00:45:07,400 --> 00:45:10,599
stuff and more stuff calls we don't need

848
00:45:10,599 --> 00:45:13,119
to check whether that pointer is non

849
00:45:13,119 --> 00:45:16,079
more we know it because otherwise we

850
00:45:16,079 --> 00:45:18,480
would never get to that

851
00:45:18,480 --> 00:45:21,800
code so this makes it relatively

852
00:45:21,800 --> 00:45:25,440
straightforward to uh program with this

853
00:45:25,440 --> 00:45:28,119
types uh meaning programming the happy

854
00:45:28,119 --> 00:45:31,200
pads the error handling pads are above

855
00:45:31,200 --> 00:45:32,640
outside and

856
00:45:32,640 --> 00:45:36,839
elsewhere so their complexity is uh is

857
00:45:36,839 --> 00:45:40,000
not going to vanish but uh it can be

858
00:45:40,000 --> 00:45:45,480
separated out which is useful so if we

859
00:45:45,480 --> 00:45:47,839
look at

860
00:45:48,880 --> 00:45:53,160
this yeah yeah that's that's the idea it

861
00:45:53,160 --> 00:45:57,079
doesn't have to be but

862
00:45:57,079 --> 00:45:59,440
I mean I could I could just use a unique

863
00:45:59,440 --> 00:46:02,440
pointer of D for the

864
00:46:02,440 --> 00:46:07,079
PTR I just like like reillustrated that

865
00:46:07,079 --> 00:46:08,960
polymorphism

866
00:46:08,960 --> 00:46:13,040
there but yeah so if that make unique

867
00:46:13,040 --> 00:46:16,880
fail it will throw an

868
00:46:19,800 --> 00:46:23,280
exception so if the make unique fails it

869
00:46:23,280 --> 00:46:26,559
throws and then we never have the PTR

870
00:46:26,559 --> 00:46:27,599
object

871
00:46:27,599 --> 00:46:30,640
we never encounter the the do stuff and

872
00:46:30,640 --> 00:46:34,240
more stuff code we never go there F will

873
00:46:34,240 --> 00:46:36,160
throw that exception because we don't

874
00:46:36,160 --> 00:46:39,599
catch it here f is basically transparent

875
00:46:39,599 --> 00:46:42,640
to the uh exceptions thrown by

876
00:46:42,640 --> 00:46:46,760
operations in it and it will just end up

877
00:46:46,760 --> 00:46:50,240
uh emitting the same exception that uh

878
00:46:50,240 --> 00:46:52,319
make unique W if it

879
00:46:52,319 --> 00:46:55,920
fails and then indeed in this particular

880
00:46:55,920 --> 00:46:58,359
case we do know that the pointer isn't

881
00:46:58,359 --> 00:47:02,920
null so we can just D reference it uh

882
00:47:02,920 --> 00:47:05,880
with without any

883
00:47:06,079 --> 00:47:09,240
hesitation in code where we wouldn't see

884
00:47:09,240 --> 00:47:12,000
that initialization we would need to

885
00:47:12,000 --> 00:47:13,960
verify whether the pointer actually

886
00:47:13,960 --> 00:47:16,440
points to anything it could be

887
00:47:16,440 --> 00:47:19,599
zero in this particular case it can't we

888
00:47:19,599 --> 00:47:22,839
know that by

889
00:47:22,839 --> 00:47:25,559
construction because we are using a

890
00:47:25,559 --> 00:47:27,480
const unique pointer here

891
00:47:27,480 --> 00:47:30,559
here I could have all sorts of

892
00:47:30,559 --> 00:47:33,720
intermediate code between that

893
00:47:33,720 --> 00:47:36,319
initialization and the US is in do in

894
00:47:36,319 --> 00:47:39,319
the ca of do stuff and more stuff but

895
00:47:39,319 --> 00:47:41,640
that doesn't matter because I know that

896
00:47:41,640 --> 00:47:44,599
a const unique pointer can be

897
00:47:44,599 --> 00:47:47,920
reset it will always point to the same

898
00:47:47,920 --> 00:47:51,160
object that was given to it when it was

899
00:47:51,160 --> 00:47:53,920
constructed that's what makes a const

900
00:47:53,920 --> 00:47:58,079
unique pointer an actual art a pure R AI

901
00:47:58,079 --> 00:48:01,319
type because you can't zero it and then

902
00:48:01,319 --> 00:48:04,079
we can rely on that by

903
00:48:04,079 --> 00:48:07,200
Just For example not doing checks that

904
00:48:07,200 --> 00:48:11,919
we would otherwise be compelled to

905
00:48:12,000 --> 00:48:16,559
do so it it makes the uh code that

906
00:48:16,559 --> 00:48:18,240
doesn't need to worry about error

907
00:48:18,240 --> 00:48:20,440
handling more

908
00:48:20,440 --> 00:48:22,480
straightforward and it makes it more

909
00:48:22,480 --> 00:48:25,359
straightforward to rely on an object

910
00:48:25,359 --> 00:48:28,760
being there

911
00:48:28,760 --> 00:48:32,480
so f is of course all these codes are

912
00:48:32,480 --> 00:48:33,920
the success

913
00:48:33,920 --> 00:48:36,599
Parts but they are very very

914
00:48:36,599 --> 00:48:39,160
straightforward very TST very clean you

915
00:48:39,160 --> 00:48:41,480
will have the error handling code

916
00:48:41,480 --> 00:48:44,440
elsewhere but the happy path is very

917
00:48:44,440 --> 00:48:46,480
straightforward and actually works

918
00:48:46,480 --> 00:48:49,119
correctly in the sense that you get

919
00:48:49,119 --> 00:48:51,520
correct cleanup you get the right kind

920
00:48:51,520 --> 00:48:54,240
of Errors reported they are just handled

921
00:48:54,240 --> 00:48:57,240
elsewhere

922
00:49:03,319 --> 00:49:07,759
sorry fun

923
00:49:07,960 --> 00:49:12,640
exception yes so if if the construction

924
00:49:12,640 --> 00:49:16,760
and or allocation of of the D object in

925
00:49:16,760 --> 00:49:20,880
the call did make unique D fails that

926
00:49:20,880 --> 00:49:23,520
throws and that exception then escapes

927
00:49:23,520 --> 00:49:25,520
out of the function

928
00:49:25,520 --> 00:49:29,359
f what in the construct we allocate two

929
00:49:29,359 --> 00:49:32,440
two resources first one Su second one

930
00:49:32,440 --> 00:49:35,559
Sal we have to hand

931
00:49:35,559 --> 00:49:37,240
it

932
00:49:37,240 --> 00:49:41,160
no so just repeating in case the online

933
00:49:41,160 --> 00:49:44,280
people didn't hear if you have two

934
00:49:44,280 --> 00:49:47,920
resources uh and the uh initialization

935
00:49:47,920 --> 00:49:49,920
of the first one succeeds and the second

936
00:49:49,920 --> 00:49:53,440
one fails what you need to do is bind

937
00:49:53,440 --> 00:49:57,799
your allocation allocated objects into a

938
00:49:57,799 --> 00:50:00,880
rappers so the first one succeeds it

939
00:50:00,880 --> 00:50:03,520
will give you a valid unique pointer the

940
00:50:03,520 --> 00:50:06,280
second one will fail that second unique

941
00:50:06,280 --> 00:50:09,960
pointer never exists but when we escape

942
00:50:09,960 --> 00:50:13,319
that scope we call the destructor of the

943
00:50:13,319 --> 00:50:15,599
first

944
00:50:17,359 --> 00:50:22,400
one an excellent question by so if we

945
00:50:22,400 --> 00:50:25,119
look in look back at the first section

946
00:50:25,119 --> 00:50:26,760
where we went through all kinds of

947
00:50:26,760 --> 00:50:29,440
examples of of resource management

948
00:50:29,440 --> 00:50:32,640
types that clean do various kinds of

949
00:50:32,640 --> 00:50:34,000
cleanup

950
00:50:34,000 --> 00:50:37,319
uh Vector fstream unit pointer and share

951
00:50:37,319 --> 00:50:40,920
pointer as such aren't really pure ra

952
00:50:40,920 --> 00:50:44,599
types because they can be empty so they

953
00:50:44,599 --> 00:50:46,640
don't always exist in a state where a

954
00:50:46,640 --> 00:50:48,119
resource is

955
00:50:48,119 --> 00:50:51,520
owned uh the standard Library tends to

956
00:50:51,520 --> 00:50:53,440
allow this kind of

957
00:50:53,440 --> 00:50:56,720
flexibility so even though they are

958
00:50:56,720 --> 00:50:59,319
standard Library types we don't

959
00:50:59,319 --> 00:51:03,559
follow R religiously in in the design of

960
00:51:03,559 --> 00:51:06,799
the standard Library types

961
00:51:06,799 --> 00:51:10,160
so as exemplified in the in the example

962
00:51:10,160 --> 00:51:12,559
that uses a con unique

963
00:51:12,559 --> 00:51:15,200
pointer but there's a super flow

964
00:51:15,200 --> 00:51:17,799
underscore there but yeah a unique

965
00:51:17,799 --> 00:51:21,240
pointer that is Con initialized by make

966
00:51:21,240 --> 00:51:26,760
unique that's say to R object that kind

967
00:51:26,760 --> 00:51:29,720
of an object always has the resource

968
00:51:29,720 --> 00:51:31,280
underneath

969
00:51:31,280 --> 00:51:34,240
it but a const unique pointer still

970
00:51:34,240 --> 00:51:39,319
isn't a pure RI type because you could

971
00:51:39,319 --> 00:51:42,599
create it as empty and then it wouldn't

972
00:51:42,599 --> 00:51:45,160
own any kind of

973
00:51:45,160 --> 00:51:48,200
resour but uh if you can use exceptions

974
00:51:48,200 --> 00:51:50,680
in your code it's worth considering to

975
00:51:50,680 --> 00:51:55,359
make your own types toly R when possible

976
00:51:55,359 --> 00:51:57,920
so that you can you can rely on them

977
00:51:57,920 --> 00:52:01,960
actually having an object in

978
00:52:02,599 --> 00:52:07,400
them that concludes the

979
00:52:11,559 --> 00:52:13,440
presentation is there any kind of

980
00:52:13,440 --> 00:52:16,440
problem with the incor slicing of

981
00:52:16,440 --> 00:52:19,559
pointers and how would

982
00:52:19,559 --> 00:52:23,400
hand so

983
00:52:23,920 --> 00:52:27,040
um yes there's a slicing problem if you

984
00:52:27,040 --> 00:52:30,119
have the base class and the derived

985
00:52:30,119 --> 00:52:33,359
class and the D structure isn't

986
00:52:33,359 --> 00:52:37,640
virtual if you create a unique pointer

987
00:52:37,640 --> 00:52:41,200
to the base type and initialize it with

988
00:52:41,200 --> 00:52:44,000
an object of well a pointer of the

989
00:52:44,000 --> 00:52:48,520
derived type it will not do the cleanup

990
00:52:48,520 --> 00:52:51,880
correctly same same thing happens if if

991
00:52:51,880 --> 00:52:53,400
you create

992
00:52:53,400 --> 00:52:57,240
a unique pointer of the

993
00:52:57,240 --> 00:52:58,960
of the derived

994
00:52:58,960 --> 00:53:02,079
type and then initialize a unique

995
00:53:02,079 --> 00:53:04,799
pointer of the base type it's still

996
00:53:04,799 --> 00:53:07,319
doesn't clean up correctly because the

997
00:53:07,319 --> 00:53:11,760
uh unique pointer will uh will just know

998
00:53:11,760 --> 00:53:14,160
how to destroy through the pointer to

999
00:53:14,160 --> 00:53:17,359
base so if that operation isn't virtual

1000
00:53:17,359 --> 00:53:19,880
it's not going to work

1001
00:53:19,880 --> 00:53:23,480
correctly yeah you you can uh shed

1002
00:53:23,480 --> 00:53:26,160
pointer has that magical superpower that

1003
00:53:26,160 --> 00:53:30,319
they it records the actual concrete

1004
00:53:30,319 --> 00:53:33,280
type for the uh for the actual cleanup

1005
00:53:33,280 --> 00:53:37,040
block so you can you can use it so that

1006
00:53:37,040 --> 00:53:39,480
even even if your cleanup isn't virtual

1007
00:53:39,480 --> 00:53:41,839
when you create an object of the most

1008
00:53:41,839 --> 00:53:43,400
derived

1009
00:53:43,400 --> 00:53:47,480
type it will record a cleanup of that

1010
00:53:47,480 --> 00:53:49,559
type inside the share

1011
00:53:49,559 --> 00:53:52,200
pointer and it will hide that behind the

1012
00:53:52,200 --> 00:53:55,240
polymorphic interface isn't it better to

1013
00:53:55,240 --> 00:53:58,439
shirt poter

1014
00:53:58,640 --> 00:54:03,160
uh well there is a common piece of

1015
00:54:03,160 --> 00:54:05,359
advice that you shouldn't over you Shar

1016
00:54:05,359 --> 00:54:08,520
pointers because they they introduce

1017
00:54:08,520 --> 00:54:11,200
longer lifetimes than you might

1018
00:54:11,200 --> 00:54:14,160
like and they also incur the uh

1019
00:54:14,160 --> 00:54:17,040
reference counting overhead if you have

1020
00:54:17,040 --> 00:54:19,720
a simple ownership relationship where

1021
00:54:19,720 --> 00:54:22,400
you can say that this piece of code this

1022
00:54:22,400 --> 00:54:25,760
COPE in my code owns that particular

1023
00:54:25,760 --> 00:54:27,240
object

1024
00:54:27,240 --> 00:54:30,040
then unique pointer is the closest

1025
00:54:30,040 --> 00:54:31,599
expression of that

1026
00:54:31,599 --> 00:54:34,680
intent because it it

1027
00:54:34,680 --> 00:54:37,920
then unless you do an explicit move

1028
00:54:37,920 --> 00:54:41,480
operation it doesn't just transfer out

1029
00:54:41,480 --> 00:54:42,960
of that

1030
00:54:42,960 --> 00:54:46,319
scope but share poters by Nature are

1031
00:54:46,319 --> 00:54:49,319
copyable and you can just uh so you can

1032
00:54:49,319 --> 00:54:51,160
both copy and move

1033
00:54:51,160 --> 00:54:54,200
them and

1034
00:54:54,200 --> 00:54:57,559
it's not exactly POS able to determine

1035
00:54:57,559 --> 00:54:59,720
by just looking at code that is that is

1036
00:54:59,720 --> 00:55:01,280
using shared

1037
00:55:01,280 --> 00:55:05,000
pointers where the actual ownerships are

1038
00:55:05,000 --> 00:55:07,559
because it's shared they are very often

1039
00:55:07,559 --> 00:55:10,640
used that you don't even want to care

1040
00:55:10,640 --> 00:55:12,839
how many shared owners you

1041
00:55:12,839 --> 00:55:16,040
have so that you can you can write call

1042
00:55:16,040 --> 00:55:18,839
back code and uh threadit code where you

1043
00:55:18,839 --> 00:55:22,160
have multiple share pointers to the same

1044
00:55:22,160 --> 00:55:24,960
object in different threads at different

1045
00:55:24,960 --> 00:55:28,000
times and then when the final one goes

1046
00:55:28,000 --> 00:55:30,720
away it will just clean up

1047
00:55:30,720 --> 00:55:33,200
automatically but if you if you have

1048
00:55:33,200 --> 00:55:36,520
straightforward single a single threaded

1049
00:55:36,520 --> 00:55:40,680
code I wouldn't say that it's worth the

1050
00:55:40,680 --> 00:55:44,720
trouble the conceptual complexity of a

1051
00:55:44,720 --> 00:55:48,880
Shar shared ownership type to use it

1052
00:55:48,880 --> 00:55:51,720
just to get better better handling of of

1053
00:55:51,720 --> 00:55:55,200
polymorph types in some cases that might

1054
00:55:55,200 --> 00:55:57,839
be fine I mean if if if you know that

1055
00:55:57,839 --> 00:55:59,480
you're not going to pass those shed

1056
00:55:59,480 --> 00:56:02,960
points elsewhere you can

1057
00:56:02,960 --> 00:56:06,000
do let's just say interesting hacks with

1058
00:56:06,000 --> 00:56:09,280
it so that it will clean up properly

1059
00:56:09,280 --> 00:56:13,280
even even if the hierarchy is not

1060
00:56:13,400 --> 00:56:15,799
polymorphic and some sometimes you

1061
00:56:15,799 --> 00:56:18,839
actually want to create

1062
00:56:18,839 --> 00:56:22,599
objects and pass out like return a bag

1063
00:56:22,599 --> 00:56:24,760
of share

1064
00:56:24,760 --> 00:56:28,599
pointers just for cleanup purposes so

1065
00:56:28,599 --> 00:56:31,760
that's that's why that uh case of a

1066
00:56:31,760 --> 00:56:35,319
share pointer void is valid so you

1067
00:56:35,319 --> 00:56:38,160
create your object with the proper

1068
00:56:38,160 --> 00:56:39,119
object

1069
00:56:39,119 --> 00:56:42,280
type and create a SharePoint of that

1070
00:56:42,280 --> 00:56:45,319
type and then you convert it to a share

1071
00:56:45,319 --> 00:56:48,640
pointer of void and pass like return it

1072
00:56:48,640 --> 00:56:51,880
or create a container of those things

1073
00:56:51,880 --> 00:56:54,240
whatever bag of those things and return

1074
00:56:54,240 --> 00:56:58,240
it for the user that user then can't

1075
00:56:58,240 --> 00:57:01,880
unless you know certain things like be

1076
00:57:01,880 --> 00:57:04,799
able you could you could try doing doing

1077
00:57:04,799 --> 00:57:08,440
static cost of course but you you can't

1078
00:57:08,440 --> 00:57:10,920
reliably get to the object so that kind

1079
00:57:10,920 --> 00:57:13,920
of return bag of shed point of void is

1080
00:57:13,920 --> 00:57:16,680
there just so that you can clean it up

1081
00:57:16,680 --> 00:57:19,680
when it's no longer

1082
00:57:21,839 --> 00:57:24,440
necessary yeah I mean you can you can

1083
00:57:24,440 --> 00:57:26,440
use that

1084
00:57:26,440 --> 00:57:28,400
in all kinds of

1085
00:57:28,400 --> 00:57:32,240
situations again prop probably in in

1086
00:57:32,240 --> 00:57:35,400
concurrent or multi-threaded uh

1087
00:57:35,400 --> 00:57:38,039
operations where you just have that one

1088
00:57:38,039 --> 00:57:40,280
thing that owns the back of your object

1089
00:57:40,280 --> 00:57:43,000
it doesn't care about operating with

1090
00:57:43,000 --> 00:57:45,359
them in any other way so it

1091
00:57:45,359 --> 00:57:47,920
doesn't need to care about the actual

1092
00:57:47,920 --> 00:57:49,400
concrete

1093
00:57:49,400 --> 00:57:51,920
pipes but then when it cleans those

1094
00:57:51,920 --> 00:57:54,000
things up it just destroys the shed

1095
00:57:54,000 --> 00:57:57,079
pointers a void and that will end up

1096
00:57:57,079 --> 00:57:59,680
calling the right kind of

1097
00:57:59,680 --> 00:58:03,720
distructor for the actual concrete

1098
00:58:03,720 --> 00:58:08,039
pipe do it also called

1099
00:58:08,039 --> 00:58:12,280
chain so the destructor chain happens as

1100
00:58:12,280 --> 00:58:15,680
it always does in C++ so that when you

1101
00:58:15,680 --> 00:58:18,039
destroy an object it subobjects are

1102
00:58:18,039 --> 00:58:20,880
destroyed so base base sub objects and

1103
00:58:20,880 --> 00:58:22,280
members are

1104
00:58:22,280 --> 00:58:24,920
destroyed

1105
00:58:24,920 --> 00:58:27,799
so it doesn't need to I mean when you

1106
00:58:27,799 --> 00:58:30,400
call an object's Destructor that will

1107
00:58:30,400 --> 00:58:34,119
destroy the the members and bases so it

1108
00:58:34,119 --> 00:58:37,400
goes upwards from that

1109
00:58:39,359 --> 00:58:41,880
point and that's that's what share

1110
00:58:41,880 --> 00:58:44,960
pointer actually does if we uh let's

1111
00:58:44,960 --> 00:58:49,799
see where did I put that

1112
00:58:54,799 --> 00:58:56,680
down right

1113
00:58:56,680 --> 00:59:02,160
so when we have that second PTR or well

1114
00:59:02,160 --> 00:59:04,839
whichever destroying that share pointer

1115
00:59:04,839 --> 00:59:07,280
will invoke the distructor of

1116
00:59:07,280 --> 00:59:10,240
D that's just what it

1117
00:59:10,240 --> 00:59:13,640
does and then of course D will destroy

1118
00:59:13,640 --> 00:59:16,680
its uh its sub objects so we then sub

1119
00:59:16,680 --> 00:59:18,880
destroying the

1120
00:59:18,880 --> 00:59:22,319
base so that that just happens like it

1121
00:59:22,319 --> 00:59:26,160
usually happens in z

1122
00:59:26,760 --> 00:59:29,920
here's a comment

1123
00:59:29,920 --> 00:59:32,039
from

1124
00:59:32,039 --> 00:59:35,640
ah yes

1125
00:59:37,160 --> 00:59:40,760
share really difficultas

1126
00:59:40,760 --> 00:59:44,280
life well yeah I mean that's that's kind

1127
00:59:44,280 --> 00:59:47,000
of we could use a sound a sound bite

1128
00:59:47,000 --> 00:59:49,440
saying that shared ownership is nobody's

1129
00:59:49,440 --> 00:59:52,760
ownership so you can't really tell by

1130
00:59:52,760 --> 00:59:55,720
statically looking at your code with

1131
00:59:55,720 --> 00:59:59,160
either an anal analysis tool or just as

1132
00:59:59,160 --> 01:00:02,200
a human reader where the actual

1133
01:00:02,200 --> 01:00:04,200
destruction will happen you know where

1134
01:00:04,200 --> 01:00:07,280
the reference count decrements happen

1135
01:00:07,280 --> 01:00:11,799
but it's uh basically impossible to tell

1136
01:00:11,799 --> 01:00:14,920
where the actual distruction happens so

1137
01:00:14,920 --> 01:00:18,039
that can indeed uh turn various code

1138
01:00:18,039 --> 01:00:22,240
bases into difficult reason about

1139
01:00:22,240 --> 01:00:25,520
mess but in somea in some cases that can

1140
01:00:25,520 --> 01:00:27,839
also remove leaks from your code and

1141
01:00:27,839 --> 01:00:29,319
make it make

1142
01:00:29,319 --> 01:00:34,240
it make it perform or behave

1143
01:00:34,240 --> 01:00:37,880
correctly I did a uh search and

1144
01:00:37,880 --> 01:00:41,720
replace refactoring on a corporate code

1145
01:00:41,720 --> 01:00:45,720
base 20 years ago where we just did a

1146
01:00:45,720 --> 01:00:48,839
search and replace of raw pointers to

1147
01:00:48,839 --> 01:00:52,079
share pointers because we had so many

1148
01:00:52,079 --> 01:00:57,200
memory leaks and uh use is after after

1149
01:00:57,200 --> 01:01:00,160
the allocations meaning that we had

1150
01:01:00,160 --> 01:01:02,559
leaks and crashes

1151
01:01:02,559 --> 01:01:05,880
there and since we didn't actually write

1152
01:01:05,880 --> 01:01:07,839
that code it came from a subcontractor

1153
01:01:07,839 --> 01:01:10,280
we didn't hope to understand it well

1154
01:01:10,280 --> 01:01:12,079
enough to find out where all the

1155
01:01:12,079 --> 01:01:16,079
problems are so we just decided to apply

1156
01:01:16,079 --> 01:01:18,960
a big hammer and turned all those raw

1157
01:01:18,960 --> 01:01:22,160
pointers into sh pointers the memory

1158
01:01:22,160 --> 01:01:24,799
leaks were gone there were no longer us

1159
01:01:24,799 --> 01:01:27,559
after free crashes and the application

1160
01:01:27,559 --> 01:01:30,839
performed according or behaved according

1161
01:01:30,839 --> 01:01:33,279
to its

1162
01:01:34,680 --> 01:01:37,440
specification we we did we did it in a

1163
01:01:37,440 --> 01:01:39,799
server application and in its clients as

1164
01:01:39,799 --> 01:01:43,880
well uh the uh maintainers of the client

1165
01:01:43,880 --> 01:01:47,599
side didn't really believe in that being

1166
01:01:47,599 --> 01:01:50,160
a workable

1167
01:01:50,160 --> 01:01:53,279
solution but we pointed out how many

1168
01:01:53,279 --> 01:01:56,400
server side bugs we were able to just Lo

1169
01:01:56,400 --> 01:01:59,599
has resolved after that operation and

1170
01:01:59,599 --> 01:02:01,839
convinced them to do the same thing on

1171
01:02:01,839 --> 01:02:05,240
their on their client side and they

1172
01:02:05,240 --> 01:02:08,680
happily reported not needing to care

1173
01:02:08,680 --> 01:02:13,319
about the like a thousand bugs instantly

1174
01:02:13,319 --> 01:02:14,760
after

1175
01:02:14,760 --> 01:02:18,640
that but yeah it it has shed shed

1176
01:02:18,640 --> 01:02:20,039
ownership has

1177
01:02:20,039 --> 01:02:24,319
cost it has that determinism cost it has

1178
01:02:24,319 --> 01:02:26,440
a complexity cost

1179
01:02:26,440 --> 01:02:29,880
and it has overhead I mean if you can

1180
01:02:29,880 --> 01:02:33,440
express a single unique ownership then

1181
01:02:33,440 --> 01:02:35,880
you should always try to do that because

1182
01:02:35,880 --> 01:02:39,440
it's just simpler in all sorts of

1183
01:02:39,440 --> 01:02:42,319
ways but sometimes you can get out of

1184
01:02:42,319 --> 01:02:44,720
all kinds of problematic situations by

1185
01:02:44,720 --> 01:02:49,879
using using a ownership my

1186
01:02:54,839 --> 01:02:58,640
pointer only know when

1187
01:02:59,960 --> 01:03:05,079
the Z oh yeah sure but the thing is

1188
01:03:05,079 --> 01:03:08,279
that if you look at a complex piece of

1189
01:03:08,279 --> 01:03:10,119
code where you have multiple share

1190
01:03:10,119 --> 01:03:12,480
pointers pointing to the same

1191
01:03:12,480 --> 01:03:16,160
object it is going to be excruciatingly

1192
01:03:16,160 --> 01:03:18,400
difficult to reason about where exactly

1193
01:03:18,400 --> 01:03:20,440
the distruction

1194
01:03:20,440 --> 01:03:23,640
happen uh I would think that's actually

1195
01:03:23,640 --> 01:03:27,000
a variation of the holding room

1196
01:03:27,000 --> 01:03:30,440
because you need you need to prove that

1197
01:03:30,440 --> 01:03:32,920
certain things happen and in certain

1198
01:03:32,920 --> 01:03:36,839
order and at the just the right times in

1199
01:03:36,839 --> 01:03:39,240
order to be able to tell that so yes of

1200
01:03:39,240 --> 01:03:41,400
course you can you can take a particular

1201
01:03:41,400 --> 01:03:44,559
Pro program and say that I can I can

1202
01:03:44,559 --> 01:03:46,960
reason about this for that particular

1203
01:03:46,960 --> 01:03:50,640
example case but in general it's not

1204
01:03:50,640 --> 01:03:53,359
even provable because it depends on the

1205
01:03:53,359 --> 01:03:56,920
uh runtime characteristics of your pro

1206
01:03:56,920 --> 01:04:01,359
program so that's why it's just

1207
01:04:01,359 --> 01:04:05,240
categorically U Sor to use unique

1208
01:04:05,240 --> 01:04:08,879
ownership models when you

1209
01:04:09,599 --> 01:04:12,880
can or if you can afford it just have a

1210
01:04:12,880 --> 01:04:15,200
wrapper that copies the result like

1211
01:04:15,200 --> 01:04:16,240
vector

1212
01:04:16,240 --> 01:04:19,200
does so if you if you have a vector of

1213
01:04:19,200 --> 01:04:21,160
strings you can take a copy of it it

1214
01:04:21,160 --> 01:04:23,960
will create a new Vector of new strings

1215
01:04:23,960 --> 01:04:26,400
that have the same data those things

1216
01:04:26,400 --> 01:04:28,200
don't have any

1217
01:04:28,200 --> 01:04:31,160
relationship so there's there's at least

1218
01:04:31,160 --> 01:04:33,599
three different things that these these

1219
01:04:33,599 --> 01:04:35,200
things can model you have unique

1220
01:04:35,200 --> 01:04:37,559
ownership shared ownership

1221
01:04:37,559 --> 01:04:40,799
and uh what should I call it it's it's

1222
01:04:40,799 --> 01:04:44,960
like a independent

1223
01:04:46,520 --> 01:04:50,480
ownersh yeah it's a typical picture uh

1224
01:04:50,480 --> 01:04:52,880
since we talking about the moving of

1225
01:04:52,880 --> 01:04:56,160
ownership in uni uh is it

1226
01:04:56,160 --> 01:04:58,960
correct to assume that uh in terms of

1227
01:04:58,960 --> 01:05:01,400
move semantic and all that we don't uh

1228
01:05:01,400 --> 01:05:04,440
certainly valide the manual uh rule of

1229
01:05:04,440 --> 01:05:08,440
fire kind of things and so like how does

1230
01:05:08,440 --> 01:05:09,359
unique

1231
01:05:09,359 --> 01:05:13,119
pointer uh handle the no dependency of a

1232
01:05:13,119 --> 01:05:15,920
move Constructor move assignment

1233
01:05:15,920 --> 01:05:18,480
operator uh talking about the user

1234
01:05:18,480 --> 01:05:22,599
defined data type well I mean if if you

1235
01:05:22,599 --> 01:05:25,680
have a unique pointer member in your

1236
01:05:25,680 --> 01:05:28,240
user defined types type then you're

1237
01:05:28,240 --> 01:05:29,200
going

1238
01:05:29,200 --> 01:05:32,319
to not going to get an automatic copy

1239
01:05:32,319 --> 01:05:34,720
operation for the

1240
01:05:34,720 --> 01:05:37,520
type you can still of course manually

1241
01:05:37,520 --> 01:05:40,599
get to the underlying data and copy it

1242
01:05:40,599 --> 01:05:44,520
if if that's valid for the actual actual

1243
01:05:44,520 --> 01:05:45,720
resource

1244
01:05:45,720 --> 01:05:49,319
type but uh since uni pointer is a move

1245
01:05:49,319 --> 01:05:52,839
only type it makes uh types wrapping it

1246
01:05:52,839 --> 01:05:56,720
move on the types as well

1247
01:05:56,720 --> 01:05:59,400
so yeah I mean that's that's a decent

1248
01:05:59,400 --> 01:06:03,039
point because when you have that kind of

1249
01:06:03,039 --> 01:06:05,839
a type if you have a vector of unique

1250
01:06:05,839 --> 01:06:08,520
pointers you can't copy those vectors

1251
01:06:08,520 --> 01:06:11,160
their element types are not

1252
01:06:11,160 --> 01:06:14,279
copyable so that is a

1253
01:06:14,279 --> 01:06:17,680
limitation like a found fundamental and

1254
01:06:17,680 --> 01:06:20,520
foundational limitation of unique

1255
01:06:20,520 --> 01:06:23,720
ownership that it leads to types that

1256
01:06:23,720 --> 01:06:25,720
aren't copiable

1257
01:06:25,720 --> 01:06:27,680
because they can't

1258
01:06:27,680 --> 01:06:32,240
be otherwise there wouldn't be unique

1259
01:06:32,240 --> 01:06:35,079
ownership but you could have vectors of

1260
01:06:35,079 --> 01:06:37,960
strings that are of course since they

1261
01:06:37,960 --> 01:06:40,359
are deep copy types those you can copy

1262
01:06:40,359 --> 01:06:43,079
to your heart's

1263
01:06:43,079 --> 01:06:46,559
content but um we we actually have

1264
01:06:46,559 --> 01:06:50,440
proposals and at the committee of uh of

1265
01:06:50,440 --> 01:06:53,880
creating a polymorphic type that copies

1266
01:06:53,880 --> 01:06:56,599
the underlying Target

1267
01:06:56,599 --> 01:07:00,279
object so uh those types are actually

1268
01:07:00,279 --> 01:07:02,119
called indirect and

1269
01:07:02,119 --> 01:07:04,880
polymorphic so in the future you can

1270
01:07:04,880 --> 01:07:07,520
create a stood Vector of uh stood

1271
01:07:07,520 --> 01:07:09,720
polymorphic of

1272
01:07:09,720 --> 01:07:13,559
T and that has deep copy semantics it

1273
01:07:13,559 --> 01:07:16,359
doesn't have unique ownership so you're

1274
01:07:16,359 --> 01:07:18,279
you're not similarly

1275
01:07:18,279 --> 01:07:20,640
limited right now the thing is that if

1276
01:07:20,640 --> 01:07:22,640
you if you actually want to create a

1277
01:07:22,640 --> 01:07:24,920
dynamically sized array of dynamically

1278
01:07:24,920 --> 01:07:27,640
allocated polymorphic

1279
01:07:27,640 --> 01:07:30,160
objects that takes you to a unique

1280
01:07:30,160 --> 01:07:33,400
ownership model but in the future it

1281
01:07:33,400 --> 01:07:36,760
won't so we are going to sort of lift

1282
01:07:36,760 --> 01:07:37,920
that

1283
01:07:37,920 --> 01:07:40,240
restriction you can of course lift it

1284
01:07:40,240 --> 01:07:43,079
today with with a custom solution if you

1285
01:07:43,079 --> 01:07:46,680
have to but yeah the uh move only

1286
01:07:46,680 --> 01:07:49,200
coupling just for the purposes of

1287
01:07:49,200 --> 01:07:52,760
getting getting Dynamic lifetimes uh

1288
01:07:52,760 --> 01:07:54,760
this is a problem that we are going to

1289
01:07:54,760 --> 01:07:57,200
fix

1290
01:07:57,200 --> 01:07:59,480
that's a very

1291
01:07:59,480 --> 01:08:02,680
question something that I

1292
01:08:02,680 --> 01:08:05,640
didn't but

1293
01:08:05,640 --> 01:08:10,000
so user Define types having Point inside

1294
01:08:10,000 --> 01:08:13,599
of them

1295
01:08:19,839 --> 01:08:23,839
Child Problem

1296
01:08:25,560 --> 01:08:29,238
sure only okay so if you if you if you

1297
01:08:29,238 --> 01:08:33,279
want that in IND Direction and

1298
01:08:33,279 --> 01:08:35,679
polymorphism then you're going to use a

1299
01:08:35,679 --> 01:08:38,198
type today that you would write as a

1300
01:08:38,198 --> 01:08:41,238
custom type that that beave behaves like

1301
01:08:41,238 --> 01:08:44,600
the uh forthcoming STD

1302
01:08:44,600 --> 01:08:47,920
polymorphic but once the STD polymorphic

1303
01:08:47,920 --> 01:08:51,319
is there you can you can just use that

1304
01:08:51,319 --> 01:08:54,839
when is it uh they they should chei in I

1305
01:08:54,839 --> 01:08:57,000
think plus plus

1306
01:08:57,000 --> 01:09:01,960
26 yeah 23 is out of the door

1307
01:09:02,439 --> 01:09:05,600
so we keep fiddling with these things

1308
01:09:05,600 --> 01:09:08,719
there's always all kinds of additions in

1309
01:09:08,719 --> 01:09:11,719
the pipeline but if you're writing a

1310
01:09:11,719 --> 01:09:15,158
competely then you

1311
01:09:16,319 --> 01:09:19,600
still well I mean that depends on if

1312
01:09:19,600 --> 01:09:20,679
you're

1313
01:09:20,679 --> 01:09:24,120
clean so if if if

1314
01:09:24,120 --> 01:09:27,279
you're if if you want that kind of deep

1315
01:09:27,279 --> 01:09:29,479
copying smart pointer I would really

1316
01:09:29,479 --> 01:09:31,520
recommend trying to find a third party

1317
01:09:31,520 --> 01:09:34,040
library that provides it before the

1318
01:09:34,040 --> 01:09:35,880
standard Library

1319
01:09:35,880 --> 01:09:39,960
does it's always a good idea to look at

1320
01:09:39,960 --> 01:09:43,198
existing libraries to provide you with h

1321
01:09:43,198 --> 01:09:44,960
this kind of

1322
01:09:44,960 --> 01:09:48,880
functionality because types like that uh

1323
01:09:48,880 --> 01:09:52,040
when we are talking about generic types

1324
01:09:52,040 --> 01:09:54,760
basically templates that provide this

1325
01:09:54,760 --> 01:09:58,239
functionality those are tricky to write

1326
01:09:58,239 --> 01:10:01,120
if if you can rely on somebody else

1327
01:10:01,120 --> 01:10:03,600
having done it for you and having

1328
01:10:03,600 --> 01:10:05,800
actually test it that it works in the

1329
01:10:05,800 --> 01:10:08,920
normal scenarios and then some in some

1330
01:10:08,920 --> 01:10:11,600
in some weird scenarios that you didn't

1331
01:10:11,600 --> 01:10:15,199
even think about that's quite often

1332
01:10:15,199 --> 01:10:17,960
better than using that type yourself to

1333
01:10:17,960 --> 01:10:22,480
write what really is a kind of sort of

1334
01:10:22,480 --> 01:10:25,480
basic utility type

1335
01:10:25,480 --> 01:10:28,960
I mean I I have an industry industry

1336
01:10:28,960 --> 01:10:32,360
background so there's always somebody a

1337
01:10:32,360 --> 01:10:34,880
customer or a manager or whoever and

1338
01:10:34,880 --> 01:10:37,040
that says that you should really ship

1339
01:10:37,040 --> 01:10:40,400
those funny toys that I would like to

1340
01:10:40,400 --> 01:10:42,800
have and if I tell them that I'm

1341
01:10:42,800 --> 01:10:45,400
fiddling with generic template code in

1342
01:10:45,400 --> 01:10:47,800
C++ they are going to give me a blank

1343
01:10:47,800 --> 01:10:51,280
stare and ask where the toys are and

1344
01:10:51,280 --> 01:10:53,320
they are not going to understand why I'm

1345
01:10:53,320 --> 01:10:56,560
fiddling with the utility libraries

1346
01:10:56,560 --> 01:10:59,280
that's why my general recommendation is

1347
01:10:59,280 --> 01:11:01,679
to try to find a library that already

1348
01:11:01,679 --> 01:11:04,199
provides that kind of a

1349
01:11:04,199 --> 01:11:06,960
type but but yeah I

1350
01:11:06,960 --> 01:11:09,560
mean getting back to the original

1351
01:11:09,560 --> 01:11:12,239
question of yours if you're modeling

1352
01:11:12,239 --> 01:11:14,760
deep copy semantics

1353
01:11:14,760 --> 01:11:17,840
uh you could reuse unique pointer it

1354
01:11:17,840 --> 01:11:20,120
doesn't hurt anything it gives you at

1355
01:11:20,120 --> 01:11:22,920
least automatic cleanup then you would

1356
01:11:22,920 --> 01:11:24,679
need to write the copy operations and

1357
01:11:24,679 --> 01:11:25,760
move operation

1358
01:11:25,760 --> 01:11:28,719
so that they work with the unique

1359
01:11:28,719 --> 01:11:32,239
pointer so it's still probably even for

1360
01:11:32,239 --> 01:11:34,320
a deep copying smart pointer it's

1361
01:11:34,320 --> 01:11:37,120
probably a better building block than

1362
01:11:37,120 --> 01:11:39,400
raw pointers are because then you would

1363
01:11:39,400 --> 01:11:41,159
need to handle

1364
01:11:41,159 --> 01:11:43,719
destruction manually and that's just

1365
01:11:43,719 --> 01:11:47,120
terrible we don't do we don't do manual

1366
01:11:47,120 --> 01:11:50,719
destruction in C++ that's old

1367
01:11:50,719 --> 01:11:54,840
school and I when I stopped doing it

1368
01:11:54,840 --> 01:11:55,840
I've

1369
01:11:55,840 --> 01:12:00,679
nobody had even planned the C++ 11 C++

1370
01:12:00,679 --> 01:12:04,159
03 was just about to be

1371
01:12:04,159 --> 01:12:06,480
standardized uh there were third party

1372
01:12:06,480 --> 01:12:09,000
libraries that provided smart pointers

1373
01:12:09,000 --> 01:12:11,280
like this this so there was a scope

1374
01:12:11,280 --> 01:12:13,639
pointer and share pointer in

1375
01:12:13,639 --> 01:12:16,760
boost and that was already enough that

1376
01:12:16,760 --> 01:12:19,280
we just said okay we are going to stop

1377
01:12:19,280 --> 01:12:22,679
using raw pointers because they

1378
01:12:22,679 --> 01:12:26,239
are tedious and terrible

1379
01:12:26,239 --> 01:12:29,799
and the very common source of

1380
01:12:34,199 --> 01:12:37,639
bugs so I would say it would require

1381
01:12:37,639 --> 01:12:39,520
really exceptional

1382
01:12:39,520 --> 01:12:41,520
circumstances where you would write a

1383
01:12:41,520 --> 01:12:44,199
custom wrapper that would use a r

1384
01:12:44,199 --> 01:12:47,040
pointer because even even if you don't

1385
01:12:47,040 --> 01:12:49,760
want the unique unique ownership in in a

1386
01:12:49,760 --> 01:12:52,040
custom like custom type like that you

1387
01:12:52,040 --> 01:12:54,719
would you would still want the automatic

1388
01:12:54,719 --> 01:12:56,840
clean up

1389
01:12:56,840 --> 01:12:59,840
semantics

1390
01:13:03,760 --> 01:13:07,639
yes you even learn

1391
01:13:10,040 --> 01:13:11,880
them

1392
01:13:11,880 --> 01:13:14,719
well so the question was whether raw

1393
01:13:14,719 --> 01:13:17,159
pointer should even be

1394
01:13:17,159 --> 01:13:19,440
learned there are all kinds of

1395
01:13:19,440 --> 01:13:22,480
situations where you run into them

1396
01:13:22,480 --> 01:13:26,280
um not all uses of Rob pointers are even

1397
01:13:26,280 --> 01:13:30,239
about Dynamic uh objects of any

1398
01:13:30,239 --> 01:13:33,920
kind in some scenarios you just use a

1399
01:13:33,920 --> 01:13:37,360
pointer like an optional object that if

1400
01:13:37,360 --> 01:13:40,239
it points to something great uh you can

1401
01:13:40,239 --> 01:13:43,400
zero it so that it doesn't point to

1402
01:13:43,400 --> 01:13:47,320
anything uh in some cases you just have

1403
01:13:47,320 --> 01:13:49,600
a pointer point to different objects of

1404
01:13:49,600 --> 01:13:52,360
the same uh of the same type at

1405
01:13:52,360 --> 01:13:53,639
different

1406
01:13:53,639 --> 01:13:56,800
times there's massive amounts of

1407
01:13:56,800 --> 01:13:59,639
existing code that doesn't use M

1408
01:13:59,639 --> 01:14:01,679
pointers even where it

1409
01:14:01,679 --> 01:14:06,080
could so in order to sur survive in the

1410
01:14:06,080 --> 01:14:09,159
wild you probably need to learn them

1411
01:14:09,159 --> 01:14:11,280
whether you actually need to learn how

1412
01:14:11,280 --> 01:14:13,440
to do dynamic memory management with

1413
01:14:13,440 --> 01:14:16,360
them is a interesting

1414
01:14:16,360 --> 01:14:19,239
question uh you can you can get

1415
01:14:19,239 --> 01:14:21,600
relatively far without ever bothering

1416
01:14:21,600 --> 01:14:23,080
about that I

1417
01:14:23,080 --> 01:14:25,920
mean it's it's often side it as a

1418
01:14:25,920 --> 01:14:27,520
possible use case that you have some

1419
01:14:27,520 --> 01:14:29,719
sort of C interface where you need to

1420
01:14:29,719 --> 01:14:31,080
pass Pro

1421
01:14:31,080 --> 01:14:35,520
pointers but if if that's an API that

1422
01:14:35,520 --> 01:14:39,040
takes a pointer to an array you can get

1423
01:14:39,040 --> 01:14:41,920
that pointer from a St Vector for

1424
01:14:41,920 --> 01:14:46,159
instance so most of your code can still

1425
01:14:46,159 --> 01:14:50,639
use containers and smart pointers and uh

1426
01:14:50,639 --> 01:14:54,080
interface with with code like that you

1427
01:14:54,080 --> 01:14:57,280
can get the pointer from a smart pointer

1428
01:14:57,280 --> 01:15:00,000
it has a function named get that does

1429
01:15:00,000 --> 01:15:01,520
exactly

1430
01:15:01,520 --> 01:15:04,000
that so there

1431
01:15:04,000 --> 01:15:06,800
are parts of the API that make it

1432
01:15:06,800 --> 01:15:10,719
interoperable with that kind of

1433
01:15:11,199 --> 01:15:16,040
techniques us for is in

1434
01:15:16,040 --> 01:15:19,960
registers reg actual

1435
01:15:20,360 --> 01:15:23,239
address yeah I mean you can you can of

1436
01:15:23,239 --> 01:15:25,639
course create a smart pointer from a

1437
01:15:25,639 --> 01:15:28,840
sorry a raw pointer from a literal

1438
01:15:28,840 --> 01:15:33,080
value where the literal value is some

1439
01:15:33,080 --> 01:15:36,800
Hardware uh address in your memory

1440
01:15:36,800 --> 01:15:40,040
space then again you don't have to use a

1441
01:15:40,040 --> 01:15:41,880
raw pointer for that you could just as

1442
01:15:41,880 --> 01:15:45,159
well have a have a non-owning smart

1443
01:15:45,159 --> 01:15:47,639
pointer and do do the similar thing to

1444
01:15:47,639 --> 01:15:48,840
that

1445
01:15:48,840 --> 01:15:51,360
so that's another thing that's missing

1446
01:15:51,360 --> 01:15:53,080
from the big

1447
01:15:53,080 --> 01:15:55,639
picture but we are going to

1448
01:15:55,639 --> 01:15:58,719
fix it hopefully soon that we actually

1449
01:15:58,719 --> 01:15:59,960
actually need

1450
01:15:59,960 --> 01:16:03,080
a resource wrapper that expresses the

1451
01:16:03,080 --> 01:16:05,000
lack of

1452
01:16:05,000 --> 01:16:06,840
ownership and

1453
01:16:06,840 --> 01:16:10,600
then that makes it even even rarer to

1454
01:16:10,600 --> 01:16:13,719
actually need a need a raw

1455
01:16:13,719 --> 01:16:16,320
pointer the problem with raw pointers in

1456
01:16:16,320 --> 01:16:18,520
general is that

1457
01:16:18,520 --> 01:16:21,960
uh the API of that sort of a type is too

1458
01:16:21,960 --> 01:16:25,880
wide you can't tell what your

1459
01:16:25,880 --> 01:16:27,920
really supposed to do with it if you

1460
01:16:27,920 --> 01:16:28,760
have a

1461
01:16:28,760 --> 01:16:31,880
pointer it can point to I mean any kind

1462
01:16:31,880 --> 01:16:35,040
of pointer but especially for raw

1463
01:16:35,040 --> 01:16:38,000
pointers it can point to a singal object

1464
01:16:38,000 --> 01:16:40,560
it can point to an array you can't tell

1465
01:16:40,560 --> 01:16:43,760
by looking at the type if it does point

1466
01:16:43,760 --> 01:16:46,800
to an to an array you can Traverse the

1467
01:16:46,800 --> 01:16:49,800
array if it doesn't point to an array

1468
01:16:49,800 --> 01:16:52,960
you can't Traverse it it's actually

1469
01:16:52,960 --> 01:16:55,520
undefined Behavior to increment the

1470
01:16:55,520 --> 01:16:58,280
pointer value if it's pointing to a

1471
01:16:58,280 --> 01:17:00,120
single

1472
01:17:00,120 --> 01:17:03,920
object so you you can you can you can

1473
01:17:03,920 --> 01:17:06,520
you can't even do the pointer

1474
01:17:06,520 --> 01:17:08,679
arithmetic then there's the other

1475
01:17:08,679 --> 01:17:11,120
problem that if you have a plane raw

1476
01:17:11,120 --> 01:17:14,199
pointer you can't tell whether it points

1477
01:17:14,199 --> 01:17:16,120
to something owned or

1478
01:17:16,120 --> 01:17:19,880
not and despite there being all kinds of

1479
01:17:19,880 --> 01:17:24,080
guidelines how you should always for for

1480
01:17:24,080 --> 01:17:28,080
example there are multiple guidelines so

1481
01:17:28,080 --> 01:17:31,600
the newer ones like the uh core

1482
01:17:31,600 --> 01:17:34,159
guidelines tell you that draw pointers

1483
01:17:34,159 --> 01:17:36,239
are always used for expressing the lack

1484
01:17:36,239 --> 01:17:37,280
of

1485
01:17:37,280 --> 01:17:40,080
ownership well that's nice if all the

1486
01:17:40,080 --> 01:17:42,360
code that you have to work with obeys

1487
01:17:42,360 --> 01:17:43,760
that

1488
01:17:43,760 --> 01:17:46,480
guideline there are exactly opposite

1489
01:17:46,480 --> 01:17:48,600
Legacy guidelines that say that if you

1490
01:17:48,600 --> 01:17:51,560
pass ownership you use a pointer and if

1491
01:17:51,560 --> 01:17:53,639
you don't pass ownership you actually

1492
01:17:53,639 --> 01:17:55,719
use a reference

1493
01:17:55,719 --> 01:17:58,000
which also doesn't work because you

1494
01:17:58,000 --> 01:18:01,280
can't always pass a reference

1495
01:18:01,280 --> 01:18:04,360
so what smart pointers bring into the

1496
01:18:04,360 --> 01:18:06,960
picture is that the type actually talks

1497
01:18:06,960 --> 01:18:10,440
about the intended ownership it says on

1498
01:18:10,440 --> 01:18:12,880
the team that okay fine this is a unique

1499
01:18:12,880 --> 01:18:16,199
point it presumably destroys the

1500
01:18:16,199 --> 01:18:19,320
object and then you can have a different

1501
01:18:19,320 --> 01:18:21,920
kind of nonp pointer class type that

1502
01:18:21,920 --> 01:18:25,719
says that I am an indirection

1503
01:18:25,719 --> 01:18:28,880
excuse me I point to something but I

1504
01:18:28,880 --> 01:18:32,159
don't own it my destruction will not

1505
01:18:32,159 --> 01:18:35,440
destroy that object and that's

1506
01:18:35,440 --> 01:18:38,920
useful well so because there's an

1507
01:18:38,920 --> 01:18:42,840
additional thing that comes out of that

1508
01:18:42,840 --> 01:18:45,480
not knowing what a r pointer points to

1509
01:18:45,480 --> 01:18:47,199
and whether you own

1510
01:18:47,199 --> 01:18:50,719
it typewise you can always pass it to a

1511
01:18:50,719 --> 01:18:52,400
delete

1512
01:18:52,400 --> 01:18:56,600
expression so uh it's going to compile

1513
01:18:56,600 --> 01:18:59,120
and do whatever incorrect things at run

1514
01:18:59,120 --> 01:19:01,840
time if you delete something that you

1515
01:19:01,840 --> 01:19:04,840
didn't actually own and that it didn't

1516
01:19:04,840 --> 01:19:07,320
actually point to a single object

1517
01:19:07,320 --> 01:19:10,760
because for race you need to use the

1518
01:19:10,760 --> 01:19:13,719
double bracket version of

1519
01:19:13,719 --> 01:19:16,560
delete that's the beauty of smart

1520
01:19:16,560 --> 01:19:19,000
pointers is that they are not pointed

1521
01:19:19,000 --> 01:19:21,920
you can't delete a unique

1522
01:19:21,920 --> 01:19:24,800
pointer the compiler will just tell you

1523
01:19:24,800 --> 01:19:26,920
that this is not an actual pointer the

1524
01:19:26,920 --> 01:19:31,800
delete delete operate expression doesn't

1525
01:19:31,800 --> 01:19:35,560
apply so it turns off things like that

1526
01:19:35,560 --> 01:19:37,800
as well when when you're using these

1527
01:19:37,800 --> 01:19:39,080
kinds of

1528
01:19:39,080 --> 01:19:43,360
types all over the place in your code

1529
01:19:43,360 --> 01:19:46,800
you're going to not notice a significant

1530
01:19:46,800 --> 01:19:49,760
decrease in the occurrences of the words

1531
01:19:49,760 --> 01:19:52,760
new and delete in your source code I

1532
01:19:52,760 --> 01:19:55,760
mean delete will

1533
01:19:55,760 --> 01:19:58,040
it's not going to be

1534
01:19:58,040 --> 01:20:01,920
anywhere and uh you're you're going to

1535
01:20:01,920 --> 01:20:07,159
adopt a principle style and guideline

1536
01:20:07,159 --> 01:20:09,639
where you start considering occurrences

1537
01:20:09,639 --> 01:20:10,920
of delete

1538
01:20:10,920 --> 01:20:14,120
Aug so that when you find it in in any

1539
01:20:14,120 --> 01:20:15,880
code you're going to start asking

1540
01:20:15,880 --> 01:20:17,600
questions what's going on here you

1541
01:20:17,600 --> 01:20:20,440
shouldn't do

1542
01:20:20,440 --> 01:20:24,440
this that's sadly not quite the case for

1543
01:20:24,440 --> 01:20:25,520
new

1544
01:20:25,520 --> 01:20:28,960
because new has a placement form

1545
01:20:28,960 --> 01:20:31,560
so that means that it can take an

1546
01:20:31,560 --> 01:20:35,120
existing address that points to a memory

1547
01:20:35,120 --> 01:20:37,280
location which means that it doesn't

1548
01:20:37,280 --> 01:20:39,679
allocate memory it just says that over

1549
01:20:39,679 --> 01:20:41,639
there construct these

1550
01:20:41,639 --> 01:20:45,440
objects with a dynamic storage

1551
01:20:45,440 --> 01:20:47,880
duration we had high hopes that a

1552
01:20:47,880 --> 01:20:50,360
library function called construct that

1553
01:20:50,360 --> 01:20:53,280
would just supersede that

1554
01:20:53,280 --> 01:20:55,560
functionality but there are dark corners

1555
01:20:55,560 --> 01:20:57,440
of the language where we realize we

1556
01:20:57,440 --> 01:21:00,800
can't do that full replacement because

1557
01:21:00,800 --> 01:21:04,120
there are copy elision scenarios where

1558
01:21:04,120 --> 01:21:07,520
construct at doesn't work it fails to

1559
01:21:07,520 --> 01:21:11,000
elide copies whereas a placement new

1560
01:21:11,000 --> 01:21:13,679
will happily Elite those

1561
01:21:13,679 --> 01:21:17,639
copies so we might we might need to

1562
01:21:17,639 --> 01:21:20,760
entertain some sort of a magic function

1563
01:21:20,760 --> 01:21:22,880
that looks like a function but isn't so

1564
01:21:22,880 --> 01:21:26,159
that it could avoid that problem or

1565
01:21:26,159 --> 01:21:28,280
maybe we just need to live with certain

1566
01:21:28,280 --> 01:21:31,239
forms of new being with us

1567
01:21:31,239 --> 01:21:34,880
forever but uh those are probably going

1568
01:21:34,880 --> 01:21:37,040
to be not so common

1569
01:21:37,040 --> 01:21:39,679
scenarios so it's perfectly reasonable

1570
01:21:39,679 --> 01:21:42,000
to get into a situation where you have

1571
01:21:42,000 --> 01:21:44,600
large amounts of C++ code where you see

1572
01:21:44,600 --> 01:21:48,360
neither the word new nor nor the word

1573
01:21:48,360 --> 01:21:52,239
delete yes sir

1574
01:21:52,239 --> 01:21:55,080
C C++ two

1575
01:21:55,080 --> 01:21:58,320
yeah which

1576
01:22:00,920 --> 01:22:06,040
one uh so I mean there's there is a a

1577
01:22:06,040 --> 01:22:08,400
bunch of languages that

1578
01:22:08,400 --> 01:22:11,679
are designed with the goal of replacing

1579
01:22:11,679 --> 01:22:15,480
C++ in mind Google has one of those

1580
01:22:15,480 --> 01:22:20,159
there is that cpp2 front end which uh

1581
01:22:20,159 --> 01:22:22,159
provides a language that has

1582
01:22:22,159 --> 01:22:25,320
a has a new syntax but is is compatible

1583
01:22:25,320 --> 01:22:28,679
with the old one because it just compar

1584
01:22:28,679 --> 01:22:32,400
the new uh new language into the old one

1585
01:22:32,400 --> 01:22:38,080
it performs a compile fr the trans

1586
01:22:38,080 --> 01:22:41,600
transformation I don't have time to pay

1587
01:22:41,600 --> 01:22:44,480
attention to the progress of those

1588
01:22:44,480 --> 01:22:49,800
projects and uh I have on my to-do list

1589
01:22:49,800 --> 01:22:54,199
various U getting familiar with other

1590
01:22:54,199 --> 01:22:56,960
more important languages I mean I

1591
01:22:56,960 --> 01:22:59,400
already need to get familiar familiar

1592
01:22:59,400 --> 01:23:02,280
with cotlin because I need to program in

1593
01:23:02,280 --> 01:23:06,800
it probably inevitably with rust for all

1594
01:23:06,800 --> 01:23:10,480
kinds of reasons and those are actually

1595
01:23:10,480 --> 01:23:13,520
specified languages not standardized but

1596
01:23:13,520 --> 01:23:16,080
specified languages that have reached

1597
01:23:16,080 --> 01:23:19,880
something that be can be called the 1. Z

1598
01:23:19,880 --> 01:23:24,520
release all of these uh C++ replacement

1599
01:23:24,520 --> 01:23:28,639
langes are not not in that stage yet so

1600
01:23:28,639 --> 01:23:30,760
I don't have enough Hobbies time and

1601
01:23:30,760 --> 01:23:33,880
energy to play with uh programming

1602
01:23:33,880 --> 01:23:37,120
languages that are that

1603
01:23:37,400 --> 01:23:41,320
immature and I I could maybe find time

1604
01:23:41,320 --> 01:23:44,960
for that to to look at them as

1605
01:23:44,960 --> 01:23:48,920
Curiosities that uh I I have in the stre

1606
01:23:48,920 --> 01:23:52,199
projects to do so playtime is

1607
01:23:52,199 --> 01:23:55,360
unfortunately a thing that I that that I

1608
01:23:55,360 --> 01:23:59,199
have but in general I do do recommend if

1609
01:23:59,199 --> 01:24:01,440
you have the time to play with all kinds

1610
01:24:01,440 --> 01:24:04,679
of different programming languag is uh

1611
01:24:04,679 --> 01:24:08,159
C++ is not a religion I mean at least to

1612
01:24:08,159 --> 01:24:12,320
me it isn't so I migrated from other

1613
01:24:12,320 --> 01:24:14,960
languages to C++ if the time comes that

1614
01:24:14,960 --> 01:24:17,600
I need to migrate away from it I will do

1615
01:24:17,600 --> 01:24:20,600
that but uh I'm I'm just saying that I

1616
01:24:20,600 --> 01:24:23,480
can't really give you accurate and

1617
01:24:23,480 --> 01:24:26,639
precise program reports on on cpp2 or

1618
01:24:26,639 --> 01:24:29,120
carbon for example because I plane don't

1619
01:24:29,120 --> 01:24:32,080
know the

1620
01:24:32,080 --> 01:24:35,400
status I got the impression that the

1621
01:24:35,400 --> 01:24:38,239
carbon folks have had some sort of

1622
01:24:38,239 --> 01:24:41,000
additional pressure to take a more

1623
01:24:41,000 --> 01:24:43,040
serious look at the memory safety of

1624
01:24:43,040 --> 01:24:43,880
that

1625
01:24:43,880 --> 01:24:46,520
language because that's that's kind of

1626
01:24:46,520 --> 01:24:48,159
the

1627
01:24:48,159 --> 01:24:52,800
uh big buzz word of today we have

1628
01:24:52,800 --> 01:24:55,719
systems level programming languages

1629
01:24:55,719 --> 01:24:58,000
meaning programming languages that don't

1630
01:24:58,000 --> 01:25:00,880
require a garbage collector or don't

1631
01:25:00,880 --> 01:25:05,960
require a um very complex runtime

1632
01:25:05,960 --> 01:25:08,480
environment that nevertheless end up

1633
01:25:08,480 --> 01:25:09,600
being

1634
01:25:09,600 --> 01:25:13,600
memorizing so you avoid more problems

1635
01:25:13,600 --> 01:25:15,639
than mentioned here I mean smart

1636
01:25:15,639 --> 01:25:19,040
pointers help you with uh accidental

1637
01:25:19,040 --> 01:25:21,920
omissions that lead to bad correctness

1638
01:25:21,920 --> 01:25:24,440
problems the memory safe programming

1639
01:25:24,440 --> 01:25:27,679
language covers much more than that so

1640
01:25:27,679 --> 01:25:29,800
in an actual actually memory safe

1641
01:25:29,800 --> 01:25:32,199
programming language you can't do out of

1642
01:25:32,199 --> 01:25:33,320
bounds

1643
01:25:33,320 --> 01:25:37,920
accesses you can do use after free mean

1644
01:25:37,920 --> 01:25:40,600
which means trying to access an object

1645
01:25:40,600 --> 01:25:42,639
through your pointer after that object

1646
01:25:42,639 --> 01:25:43,760
has been

1647
01:25:43,760 --> 01:25:46,960
destroyed so it

1648
01:25:46,960 --> 01:25:50,560
seems very plausible and likely that a

1649
01:25:50,560 --> 01:25:52,679
whole lot of programmers are going to

1650
01:25:52,679 --> 01:25:56,040
move towards that kind of programming

1651
01:25:56,040 --> 01:26:00,920
languages I mean I I am kind of drawing

1652
01:26:00,920 --> 01:26:03,560
analogies between the situation that I

1653
01:26:03,560 --> 01:26:06,679
had 20 well 30 years

1654
01:26:06,679 --> 01:26:10,440
ago when I started programming in c and

1655
01:26:10,440 --> 01:26:12,760
then moved to C++ I came to the

1656
01:26:12,760 --> 01:26:16,040
realization that C++ is much nicer

1657
01:26:16,040 --> 01:26:18,119
because it tells me that when I'm trying

1658
01:26:18,119 --> 01:26:20,719
to initialize a

1659
01:26:20,719 --> 01:26:23,280
pointer of a particular type with

1660
01:26:23,280 --> 01:26:26,360
another it tells me that those types are

1661
01:26:26,360 --> 01:26:28,080
completely unrelated and that

1662
01:26:28,080 --> 01:26:30,600
initialization is not

1663
01:26:30,600 --> 01:26:33,600
valid and see that's a warning warning

1664
01:26:33,600 --> 01:26:36,800
it's not an error and uh back then the

1665
01:26:36,800 --> 01:26:39,520
recommendation was that you don't need

1666
01:26:39,520 --> 01:26:41,040
that kind of type safety in a

1667
01:26:41,040 --> 01:26:43,520
programming language you can just run a

1668
01:26:43,520 --> 01:26:45,719
additional checking

1669
01:26:45,719 --> 01:26:48,280
tool that will then tell you that this

1670
01:26:48,280 --> 01:26:49,880
is probably

1671
01:26:49,880 --> 01:26:52,679
Incorrect and in all practical cases

1672
01:26:52,679 --> 01:26:54,480
where I ran into it I said this is

1673
01:26:54,480 --> 01:26:57,159
always incorrect it's the same thing

1674
01:26:57,159 --> 01:26:59,480
with with memory safety programmers are

1675
01:26:59,480 --> 01:27:00,679
going to

1676
01:27:00,679 --> 01:27:04,119
expect since we have practical examples

1677
01:27:04,119 --> 01:27:05,080
like

1678
01:27:05,080 --> 01:27:09,880
rust that uh when the uh memory safety

1679
01:27:09,880 --> 01:27:12,960
problems are statically

1680
01:27:12,960 --> 01:27:14,960
determinable and the programming

1681
01:27:14,960 --> 01:27:17,000
language can tell you that you have a

1682
01:27:17,000 --> 01:27:18,400
memory safety

1683
01:27:18,400 --> 01:27:21,199
bug the expectation is going to be that

1684
01:27:21,199 --> 01:27:24,520
the compiler rejects your program rather

1685
01:27:24,520 --> 01:27:26,480
than have it happily compile your

1686
01:27:26,480 --> 01:27:28,880
program then you run it and get whatever

1687
01:27:28,880 --> 01:27:31,880
disasterous

1688
01:27:32,400 --> 01:27:36,440
result that is why we are going to be

1689
01:27:36,440 --> 01:27:39,400
talking more and more about how to

1690
01:27:39,400 --> 01:27:41,639
introduce memorization facilities into

1691
01:27:41,639 --> 01:27:47,040
C++ those discussions are ongoing in the

1692
01:27:48,480 --> 01:27:51,400
committee sorry sorry what what that

1693
01:27:51,400 --> 01:27:53,760
will lead to I can't tell yet uh there

1694
01:27:53,760 --> 01:27:55,560
is a

1695
01:27:55,560 --> 01:27:59,800
safety profile approach proposed by B

1696
01:27:59,800 --> 01:28:02,239
himself that kind of suggests

1697
01:28:02,239 --> 01:28:04,600
standardizing certain different

1698
01:28:04,600 --> 01:28:09,159
different safety levels that are then uh

1699
01:28:09,159 --> 01:28:11,880
both statically checkable by the

1700
01:28:11,880 --> 01:28:14,719
compiler and then additionally doing the

1701
01:28:14,719 --> 01:28:17,840
bounce checking at run time because you

1702
01:28:17,840 --> 01:28:20,920
can statically prove all the bounce

1703
01:28:20,920 --> 01:28:23,360
checking errors that actually runs into

1704
01:28:23,360 --> 01:28:25,600
the holding problem

1705
01:28:25,600 --> 01:28:28,920
but uh there's a there's a variety of

1706
01:28:28,920 --> 01:28:31,960
suggested safety profiles like that and

1707
01:28:31,960 --> 01:28:34,639
uh we're going to be working towards

1708
01:28:34,639 --> 01:28:36,679
those

1709
01:28:36,679 --> 01:28:39,119
because not just because of the

1710
01:28:39,119 --> 01:28:42,000
so-called perhaps less technical reasons

1711
01:28:42,000 --> 01:28:46,159
about memory safety being a Hot Topic it

1712
01:28:46,159 --> 01:28:48,600
just makes sense at least in in my

1713
01:28:48,600 --> 01:28:51,239
opinion because it's it's a scalability

1714
01:28:51,239 --> 01:28:53,600
thing your language finds a bug in your

1715
01:28:53,600 --> 01:28:55,480
program so of course it should reject

1716
01:28:55,480 --> 01:28:59,199
that program if it can and that's more

1717
01:28:59,199 --> 01:29:01,199
and more going to be the ex uh

1718
01:29:01,199 --> 01:29:04,639
expectation going forward yes

1719
01:29:04,639 --> 01:29:06,679
ma'am

1720
01:29:06,679 --> 01:29:09,920
same what is the industry landscape

1721
01:29:09,920 --> 01:29:12,800
where think that memory safety will

1722
01:29:12,800 --> 01:29:13,719
never

1723
01:29:13,719 --> 01:29:16,159
be something

1724
01:29:16,159 --> 01:29:20,719
like so I mean if you want to be hyper

1725
01:29:20,719 --> 01:29:23,480
performant you're not going to be

1726
01:29:23,480 --> 01:29:27,239
enabled the uh run times runtime bounce

1727
01:29:27,239 --> 01:29:30,400
checking for for being completely

1728
01:29:30,400 --> 01:29:32,199
actually memory safe you need to do

1729
01:29:32,199 --> 01:29:34,000
runtime bounch checking because that's

1730
01:29:34,000 --> 01:29:37,040
not statically provable to be

1731
01:29:37,040 --> 01:29:42,080
correct so if you want to go as fast as

1732
01:29:42,080 --> 01:29:44,360
possible in some scenarios people are

1733
01:29:44,360 --> 01:29:47,400
not going to be performing those those

1734
01:29:47,400 --> 01:29:49,320
runtime checks and they are going to try

1735
01:29:49,320 --> 01:29:51,639
to divide their Pro problems so that

1736
01:29:51,639 --> 01:29:55,040
they are smaller and uh can be more

1737
01:29:55,040 --> 01:29:57,159
easily reasoned so that they can have

1738
01:29:57,159 --> 01:30:00,400
local proves that they are not doing out

1739
01:30:00,400 --> 01:30:02,679
of bounds accesses and then you have all

1740
01:30:02,679 --> 01:30:03,480
the

1741
01:30:03,480 --> 01:30:07,760
usual sanitizers debuggers whatever uh

1742
01:30:07,760 --> 01:30:11,000
that can in a limited fashion of course

1743
01:30:11,000 --> 01:30:14,520
subject to your testing coverage tell

1744
01:30:14,520 --> 01:30:17,280
tell you that you probably have a

1745
01:30:17,280 --> 01:30:20,280
program that is sufficiently correct

1746
01:30:20,280 --> 01:30:22,440
that you don't you don't need to care

1747
01:30:22,440 --> 01:30:25,480
about the the thetical possibilities of

1748
01:30:25,480 --> 01:30:28,520
it not being I mean this this goes to

1749
01:30:28,520 --> 01:30:33,280
practical things um there is um software

1750
01:30:33,280 --> 01:30:35,440
that's safety critical and then there's

1751
01:30:35,440 --> 01:30:38,639
software that isn't memory safety is

1752
01:30:38,639 --> 01:30:41,320
useful for both because it prevents bugs

1753
01:30:41,320 --> 01:30:42,239
from

1754
01:30:42,239 --> 01:30:45,440
occurring but when you're in a context

1755
01:30:45,440 --> 01:30:50,280
where it it isn't safety critical and it

1756
01:30:50,280 --> 01:30:54,679
already gives generates revenue for

1757
01:30:54,679 --> 01:30:57,199
uh generates revenue for you then you

1758
01:30:57,199 --> 01:30:59,520
don't need to care about whether it

1759
01:30:59,520 --> 01:31:03,760
crashes next week once or twice if the

1760
01:31:03,760 --> 01:31:06,400
overall result is that the application

1761
01:31:06,400 --> 01:31:09,679
is profitable so there's much more

1762
01:31:09,679 --> 01:31:14,480
complex uh things to consider there so

1763
01:31:14,480 --> 01:31:16,360
there are certainly scenarios where you

1764
01:31:16,360 --> 01:31:18,639
wouldn't want to do bounce checking

1765
01:31:18,639 --> 01:31:20,840
because you can you can for

1766
01:31:20,840 --> 01:31:24,239
example prod well you can you can ch at

1767
01:31:24,239 --> 01:31:26,600
money money faster if you don't have

1768
01:31:26,600 --> 01:31:29,639
that overhead so high high frequency and

1769
01:31:29,639 --> 01:31:33,440
high speed trading are examples of this

1770
01:31:33,440 --> 01:31:36,600
the more more um stock transactions you

1771
01:31:36,600 --> 01:31:39,840
can run the more money you can

1772
01:31:39,840 --> 01:31:43,000
make yes

1773
01:31:44,440 --> 01:31:47,440
sir

1774
01:31:47,560 --> 01:31:50,000
over uh

1775
01:31:50,000 --> 01:31:55,400
I yes and yes so the there's various

1776
01:31:55,400 --> 01:31:57,239
existing

1777
01:31:57,239 --> 01:32:00,560
abis where passing a raw pointer is done

1778
01:32:00,560 --> 01:32:01,800
via a

1779
01:32:01,800 --> 01:32:05,600
register but if you wrap this wrap that

1780
01:32:05,600 --> 01:32:07,600
pointer into a unique pointer you no

1781
01:32:07,600 --> 01:32:10,320
longer get pass by

1782
01:32:10,320 --> 01:32:13,679
register and uh well shed pointers of

1783
01:32:13,679 --> 01:32:16,199
course have uh all kinds of overheads I

1784
01:32:16,199 --> 01:32:18,520
mean there's a size overhead for storing

1785
01:32:18,520 --> 01:32:21,880
the reference count and uh all the

1786
01:32:21,880 --> 01:32:24,800
runtime cost of updating manipulating

1787
01:32:24,800 --> 01:32:28,280
that reference count so that's certainly

1788
01:32:28,280 --> 01:32:30,119
a around time

1789
01:32:30,119 --> 01:32:34,600
overhead um I think there are some abis

1790
01:32:34,600 --> 01:32:37,119
where that whole raw pointer versus

1791
01:32:37,119 --> 01:32:39,840
unique pointer business is not a

1792
01:32:39,840 --> 01:32:42,920
problem uh there's no size overhead in

1793
01:32:42,920 --> 01:32:45,520
in unique pointer it's exactly the same

1794
01:32:45,520 --> 01:32:48,159
size as your Ro pointer because that's

1795
01:32:48,159 --> 01:32:51,639
all it is it's a stru that wraps a wraps

1796
01:32:51,639 --> 01:32:55,119
a raw pointer it has the same alignment

1797
01:32:55,119 --> 01:32:59,480
the same size so but yeah there are even

1798
01:32:59,480 --> 01:33:02,199
for Unique pointers there are practical

1799
01:33:02,199 --> 01:33:04,800
situations where you might need to

1800
01:33:04,800 --> 01:33:06,880
consider whether you can use

1801
01:33:06,880 --> 01:33:10,600
it and that goes into those hyper

1802
01:33:10,600 --> 01:33:14,920
performance use cases where you might

1803
01:33:14,920 --> 01:33:17,920
just end up in a situation where that

1804
01:33:17,920 --> 01:33:21,440
kind of thing like how to pass a pointer

1805
01:33:21,440 --> 01:33:23,840
argument is going to be a significant

1806
01:33:23,840 --> 01:33:26,320
performance

1807
01:33:26,320 --> 01:33:30,320
difference and presumably you

1808
01:33:30,320 --> 01:33:33,719
would need to pass those things in line

1809
01:33:33,719 --> 01:33:36,760
so that they are not passed at all

1810
01:33:36,760 --> 01:33:41,719
but I I can't I can't tell what are what

1811
01:33:41,719 --> 01:33:44,320
different kinds of interesting things

1812
01:33:44,320 --> 01:33:49,119
C++ programmers enter up doing so for

1813
01:33:49,119 --> 01:33:51,800
some people it can be a cumulative

1814
01:33:51,800 --> 01:33:54,320
significant difference how how to pass a

1815
01:33:54,320 --> 01:33:57,400
pointer versus a smart pointer I mean of

1816
01:33:57,400 --> 01:34:00,280
course it adds up if you have for

1817
01:34:00,280 --> 01:34:02,080
whatever reason you need to call that

1818
01:34:02,080 --> 01:34:04,760
function that's not in lined 10 billion

1819
01:34:04,760 --> 01:34:08,040
times there is going to be a

1820
01:34:08,040 --> 01:34:11,440
difference okay so uh before you

1821
01:34:11,440 --> 01:34:13,760
mentioned that you had a task when you

1822
01:34:13,760 --> 01:34:16,280
decided to replace all the uh goall

1823
01:34:16,280 --> 01:34:19,199
pointers with the unique pointers and to

1824
01:34:19,199 --> 01:34:22,800
me oh shared from and uh to me that

1825
01:34:22,800 --> 01:34:25,719
sounds like a simple yet potentially

1826
01:34:25,719 --> 01:34:29,040
large task and this is exactly where I

1827
01:34:29,040 --> 01:34:32,040
would say AI shines at right now so I

1828
01:34:32,040 --> 01:34:35,480
was wondering my question is uh do you

1829
01:34:35,480 --> 01:34:38,119
use AI somehow in your word or what is

1830
01:34:38,119 --> 01:34:40,440
the role of AI

1831
01:34:40,440 --> 01:34:44,159
so I personally don't use TOS like

1832
01:34:44,159 --> 01:34:46,400
GitHub

1833
01:34:46,400 --> 01:34:49,199
co-pilot and I specifically don't use

1834
01:34:49,199 --> 01:34:52,080
anything that's chat GPT

1835
01:34:52,080 --> 01:34:56,400
based because I have informal training

1836
01:34:56,400 --> 01:34:58,760
on how AI

1837
01:34:58,760 --> 01:35:02,280
works I have read a couple of list books

1838
01:35:02,280 --> 01:35:05,639
when I was younger R them a couple of

1839
01:35:05,639 --> 01:35:07,719
years ago they talk about symbolic

1840
01:35:07,719 --> 01:35:12,360
processing expert systems and artificial

1841
01:35:12,360 --> 01:35:15,320
intelligence and chat GP

1842
01:35:15,320 --> 01:35:18,440
isn't an artificial

1843
01:35:18,440 --> 01:35:21,480
intellig and especially there

1844
01:35:21,480 --> 01:35:24,800
are practical examples how you can just

1845
01:35:24,800 --> 01:35:27,400
Hoodwink it to spout whatever nonsense

1846
01:35:27,400 --> 01:35:30,800
that you that you want you can give it

1847
01:35:30,800 --> 01:35:35,480
any bird and ask it uh can you tell me

1848
01:35:35,480 --> 01:35:37,920
things about this natural bird of

1849
01:35:37,920 --> 01:35:40,639
Finland and it will it will tell you

1850
01:35:40,639 --> 01:35:44,320
that what whatever vulture is the n

1851
01:35:44,320 --> 01:35:46,840
national bird of Finland and it's going

1852
01:35:46,840 --> 01:35:49,800
to come up with whatever backing story

1853
01:35:49,800 --> 01:35:55,280
for that as if as if it is a fact so

1854
01:35:55,280 --> 01:35:58,880
considering that I mean fine that's

1855
01:35:58,880 --> 01:36:01,320
that's of course an attempt to fool it

1856
01:36:01,320 --> 01:36:03,280
but it's kind of

1857
01:36:03,280 --> 01:36:06,480
a simple attempt that it you would think

1858
01:36:06,480 --> 01:36:09,800
that it it SE is through but it doesn't

1859
01:36:09,800 --> 01:36:13,679
so for for a toy example like that where

1860
01:36:13,679 --> 01:36:14,880
it doesn't

1861
01:36:14,880 --> 01:36:17,119
matter it's fine if doesn't if it

1862
01:36:17,119 --> 01:36:20,480
doesn't get the answer right but for

1863
01:36:20,480 --> 01:36:24,440
something that needs to be so precise

1864
01:36:24,440 --> 01:36:28,880
and hopefully bug free and U other other

1865
01:36:28,880 --> 01:36:31,080
properties like this expression of your

1866
01:36:31,080 --> 01:36:33,560
intent like

1867
01:36:33,560 --> 01:36:36,040
programming I wouldn't want to delegate

1868
01:36:36,040 --> 01:36:40,000
it delegate it to such a expert system

1869
01:36:40,000 --> 01:36:41,920
that has that sort of noise

1870
01:36:41,920 --> 01:36:45,280
levels I have no idea what data has been

1871
01:36:45,280 --> 01:36:48,800
used to train it I have no idea whether

1872
01:36:48,800 --> 01:36:52,920
it understands my code at the at the raw

1873
01:36:52,920 --> 01:36:54,679
language level

1874
01:36:54,679 --> 01:36:57,199
and I especially have no idea whether it

1875
01:36:57,199 --> 01:36:59,320
understands the problem domain that I'm

1876
01:36:59,320 --> 01:37:00,600
working

1877
01:37:00,600 --> 01:37:04,639
in I mean fine we can we can

1878
01:37:04,639 --> 01:37:08,040
probably have that kind of co-pilots

1879
01:37:08,040 --> 01:37:12,880
Etc that will do a more intelligent job

1880
01:37:12,880 --> 01:37:15,040
than that search and replace was because

1881
01:37:15,040 --> 01:37:19,159
that was just purely texture that I did

1882
01:37:19,159 --> 01:37:20,520
yet it

1883
01:37:20,520 --> 01:37:24,840
worked but uh near near future AIS will

1884
01:37:24,840 --> 01:37:26,800
probably be able to understand more of

1885
01:37:26,800 --> 01:37:29,760
that context and say that hey in this

1886
01:37:29,760 --> 01:37:31,960
particular case that sear and replace

1887
01:37:31,960 --> 01:37:36,040
might not be a good idea so yes that

1888
01:37:36,040 --> 01:37:38,960
kind of pre factorings may be helpful

1889
01:37:38,960 --> 01:37:42,840
when done with an AI but uh I wonder how

1890
01:37:42,840 --> 01:37:44,840
much time it will save because you will

1891
01:37:44,840 --> 01:37:48,199
need to verify everything the AI did

1892
01:37:48,199 --> 01:37:52,119
noways yes yeah you're pretty much

1893
01:37:52,119 --> 01:37:53,760
always going to need to very by

1894
01:37:53,760 --> 01:37:57,320
everything the AI do because it because

1895
01:37:57,320 --> 01:38:00,599
it's it's it's it's not you you can't

1896
01:38:00,599 --> 01:38:02,960
know that it did just the things that

1897
01:38:02,960 --> 01:38:03,840
you

1898
01:38:03,840 --> 01:38:06,480
intended so you run the risk of there

1899
01:38:06,480 --> 01:38:09,480
being completely unknown bugs that you

1900
01:38:09,480 --> 01:38:10,719
kind of

1901
01:38:10,719 --> 01:38:13,880
introduced even though well you didn't

1902
01:38:13,880 --> 01:38:17,360
use the tool to introduce them I don't I

1903
01:38:17,360 --> 01:38:19,440
don't know

1904
01:38:19,440 --> 01:38:24,560
if it works with Pro coding but uh you

1905
01:38:24,560 --> 01:38:32,800
can ask the AI to site s what sure but

1906
01:38:32,800 --> 01:38:34,560
that's the thing if you're if you're

1907
01:38:34,560 --> 01:38:38,040
going to modify a gigabyte of code with

1908
01:38:38,040 --> 01:38:41,599
it then you're still probably going to

1909
01:38:41,599 --> 01:38:44,719
want to review

1910
01:38:45,320 --> 01:38:49,719
it this is this is going to be an an

1911
01:38:49,719 --> 01:38:52,440
increasing problem going

1912
01:38:52,440 --> 01:38:55,480
forward there's always been this kind of

1913
01:38:55,480 --> 01:38:57,440
uh question of if you use a code

1914
01:38:57,440 --> 01:39:00,159
generator does it do exactly what it

1915
01:39:00,159 --> 01:39:04,000
advertises or do you need

1916
01:39:04,000 --> 01:39:08,960
to go and look at ev Everything it did

1917
01:39:08,960 --> 01:39:11,199
and verify that it's generating what you

1918
01:39:11,199 --> 01:39:13,239
thought it would be

1919
01:39:13,239 --> 01:39:15,960
generating but those tend to be at least

1920
01:39:15,960 --> 01:39:19,480
to some extent or to a very large extent

1921
01:39:19,480 --> 01:39:22,719
determinist and AI can theoretically do

1922
01:39:22,719 --> 01:39:25,360
anything

1923
01:39:25,920 --> 01:39:29,520
and then there's of course I'm I'm not

1924
01:39:29,520 --> 01:39:31,920
just a

1925
01:39:37,119 --> 01:39:40,119
second

1926
01:39:40,320 --> 01:39:43,800
no so I'm I'm not the one that's going

1927
01:39:43,800 --> 01:39:47,440
to give you these uh worst case

1928
01:39:47,440 --> 01:39:50,080
scenarios but uh there are of course

1929
01:39:50,080 --> 01:39:51,639
when when there's an arbitrary

1930
01:39:51,639 --> 01:39:54,040
transformation that is going to do

1931
01:39:54,040 --> 01:39:57,040
whatever and you don't really know what

1932
01:39:57,040 --> 01:39:59,280
it's going to be doing that opens up all

1933
01:39:59,280 --> 01:40:00,920
kinds of interesting

1934
01:40:00,920 --> 01:40:04,400
possibilities for exploits

1935
01:40:04,400 --> 01:40:07,440
Etc uh in addition to my last question

1936
01:40:07,440 --> 01:40:09,800
so you mentioned also that you learning

1937
01:40:09,800 --> 01:40:12,840
rust or trying to use it in your word

1938
01:40:12,840 --> 01:40:16,400
well I mean I'm my progress of learning

1939
01:40:16,400 --> 01:40:20,400
rust is excruciating this foe because I

1940
01:40:20,400 --> 01:40:23,320
for example have had to learn Lang

1941
01:40:23,320 --> 01:40:25,560
language is like Swift and golin on the

1942
01:40:25,560 --> 01:40:29,679
way so yeah but this is the kind of task

1943
01:40:29,679 --> 01:40:32,679
in which AI could also

1944
01:40:32,679 --> 01:40:35,239
help to teach me a new programming

1945
01:40:35,239 --> 01:40:37,960
language well they you can ask for a

1946
01:40:37,960 --> 01:40:39,599
solution

1947
01:40:39,599 --> 01:40:43,239
and study this kind of solution yeah

1948
01:40:43,239 --> 01:40:45,560
that's terrible I'm very old school at

1949
01:40:45,560 --> 01:40:48,840
learning programming languages I need to

1950
01:40:48,840 --> 01:40:50,800
understand the nuts and bolts how they

1951
01:40:50,800 --> 01:40:54,840
work I mean how the language facilities

1952
01:40:54,840 --> 01:40:57,960
work um I

1953
01:40:57,960 --> 01:41:00,480
mean I used to think that I'm not a

1954
01:41:00,480 --> 01:41:03,679
language lawyer in the very sense of the

1955
01:41:03,679 --> 01:41:06,480
word I was told after I'd been in the

1956
01:41:06,480 --> 01:41:08,400
committee that I must be because I've

1957
01:41:08,400 --> 01:41:11,520
been there for multiple years and then I

1958
01:41:11,520 --> 01:41:14,199
realized things like uh I was looking at

1959
01:41:14,199 --> 01:41:15,280
uh

1960
01:41:15,280 --> 01:41:18,239
how virtual functions work in a language

1961
01:41:18,239 --> 01:41:19,840
like Java and

1962
01:41:19,840 --> 01:41:23,639
C namely whether you can have priv with

1963
01:41:23,639 --> 01:41:25,400
virtual functions in

1964
01:41:25,400 --> 01:41:28,800
C I ended up finding that information by

1965
01:41:28,800 --> 01:41:32,360
reading the ecma spec of C which is

1966
01:41:32,360 --> 01:41:34,360
probably not what most people do when

1967
01:41:34,360 --> 01:41:37,679
they are trying to figure out how how

1968
01:41:37,679 --> 01:41:39,360
programming language

1969
01:41:39,360 --> 01:41:41,960
works well I mean I tried to look at

1970
01:41:41,960 --> 01:41:43,960
various tutorials and articles and

1971
01:41:43,960 --> 01:41:46,440
didn't find an exact precise answer to

1972
01:41:46,440 --> 01:41:49,480
my question so I had to go and read the

1973
01:41:49,480 --> 01:41:50,840
specification

1974
01:41:50,840 --> 01:41:53,920
instead because luckily I can nowadays

1975
01:41:53,920 --> 01:41:56,360
read

1976
01:41:56,400 --> 01:41:59,960
those but yeah I don't

1977
01:41:59,960 --> 01:42:04,639
uh it's it's hard to figure out how how

1978
01:42:04,639 --> 01:42:07,159
an AI could teach you a programming

1979
01:42:07,159 --> 01:42:11,280
language um it might be useful if you

1980
01:42:11,280 --> 01:42:13,400
feeded the information of what languages

1981
01:42:13,400 --> 01:42:16,760
you know before learning the new one and

1982
01:42:16,760 --> 01:42:19,520
then kind of try to focus it on that

1983
01:42:19,520 --> 01:42:22,080
that I'm interested in how this and this

1984
01:42:22,080 --> 01:42:25,159
thing is different

1985
01:42:25,440 --> 01:42:28,960
but uh I don't I don't believe AIS are

1986
01:42:28,960 --> 01:42:31,520
very good at explaining examples and

1987
01:42:31,520 --> 01:42:34,440
Transformations as in as how you do it

1988
01:42:34,440 --> 01:42:37,480
in Rust I mean sure they they produce

1989
01:42:37,480 --> 01:42:40,920
impressive comments that explain it to

1990
01:42:40,920 --> 01:42:41,760
an

1991
01:42:41,760 --> 01:42:45,360
extent but I I I'm going to end up in a

1992
01:42:45,360 --> 01:42:47,679
situation where for me personally that

1993
01:42:47,679 --> 01:42:50,719
extent is too limited it's not enough

1994
01:42:50,719 --> 01:42:52,920
for it to say that yeah well this this

1995
01:42:52,920 --> 01:42:55,000
is different because so and

1996
01:42:55,000 --> 01:42:58,360
so it's like you people looking at this

1997
01:42:58,360 --> 01:43:02,360
slideshow of mine which is uh not

1998
01:43:02,360 --> 01:43:05,480
completely free of detail but mostly so

1999
01:43:05,480 --> 01:43:07,440
if you want to learn these techniques

2000
01:43:07,440 --> 01:43:09,760
you're going to need to practice it with

2001
01:43:09,760 --> 01:43:12,760
exercises this is not going to be enough

2002
01:43:12,760 --> 01:43:16,719
for you to either learn or remember this

2003
01:43:16,719 --> 01:43:19,080
I think I would run into a similar

2004
01:43:19,080 --> 01:43:23,119
problem with with an AI based attempt to

2005
01:43:23,119 --> 01:43:24,520
learn a programming

2006
01:43:24,520 --> 01:43:27,679
language thank

2007
01:43:27,719 --> 01:43:31,520
you I mean it's say your mileage May VAR

2008
01:43:31,520 --> 01:43:34,960
situation it might be helpful for many

2009
01:43:34,960 --> 01:43:38,040
people it uh it's probably useful if you

2010
01:43:38,040 --> 01:43:41,040
really need to get out of a tight spot I

2011
01:43:41,040 --> 01:43:42,960
mean if you run into a problem that

2012
01:43:42,960 --> 01:43:45,000
here's this completely new programming

2013
01:43:45,000 --> 01:43:47,360
language we need to ship something

2014
01:43:47,360 --> 01:43:50,159
written in it and you have 15

2015
01:43:50,159 --> 01:43:53,280
minutes sure I would use an AI in that

2016
01:43:53,280 --> 01:43:58,040
case I would use whatever to help me I

2017
01:43:58,040 --> 01:44:00,320
need to write a hello word and the fate

2018
01:44:00,320 --> 01:44:03,880
of the world somehow depends on me so I

2019
01:44:03,880 --> 01:44:05,239
would

2020
01:44:05,239 --> 01:44:09,080
probably also try to use an AI in that

2021
01:44:09,080 --> 01:44:12,040
case but luckily I have I haven't run

2022
01:44:12,040 --> 01:44:15,360
into that situation

2023
01:44:15,840 --> 01:44:19,440
yet a generic good generic teacher if

2024
01:44:19,440 --> 01:44:24,119
you want an expert op it's not do

2025
01:44:24,119 --> 01:44:26,920
it just

2026
01:44:31,239 --> 01:44:34,520
what so the so the problem with how good

2027
01:44:34,520 --> 01:44:37,080
a teacher can an AI

2028
01:44:37,080 --> 01:44:41,159
be is that we don't understand cognitive

2029
01:44:41,159 --> 01:44:45,719
Sciences to a sufficient extent so we

2030
01:44:45,719 --> 01:44:48,239
don't we don't understand how how human

2031
01:44:48,239 --> 01:44:53,520
brain works at U at that kind of levels

2032
01:44:53,520 --> 01:44:56,520
if we would then we could create a

2033
01:44:56,520 --> 01:45:01,400
computer program that is an efficient

2034
01:45:01,400 --> 01:45:03,800
teacher and then you could you could do

2035
01:45:03,800 --> 01:45:06,520
something else with

2036
01:45:07,560 --> 01:45:10,560
your

2037
01:45:11,719 --> 01:45:15,599
yeah yeah well that's that's the reason

2038
01:45:15,599 --> 01:45:18,760
why I said that CH CET GPT in particular

2039
01:45:18,760 --> 01:45:23,960
isn't an AI it's it it has a new and

2040
01:45:23,960 --> 01:45:26,960
improved language model and then it

2041
01:45:26,960 --> 01:45:29,280
crunches data better than the previous

2042
01:45:29,280 --> 01:45:33,719
ones did but it it's not going to invent

2043
01:45:33,719 --> 01:45:37,599
anything for you like ever

2044
01:45:37,599 --> 01:45:41,239
so it might pass certain classical

2045
01:45:41,239 --> 01:45:42,760
intelligence

2046
01:45:42,760 --> 01:45:46,560
tests but whether it's truly intelligent

2047
01:45:46,560 --> 01:45:49,320
we are still very far from that

2048
01:45:49,320 --> 01:45:52,000
point and uh I don't I don't think we

2049
01:45:52,000 --> 01:45:55,400
know what it takes to get to that point

2050
01:45:55,400 --> 01:45:57,119
so that's

2051
01:45:57,119 --> 01:46:00,560
why due to those traditional definitions

2052
01:46:00,560 --> 01:46:03,880
I I am kind of allergic to what all

2053
01:46:03,880 --> 01:46:06,920
sorts of things are called AI nowadays

2054
01:46:06,920 --> 01:46:09,119
when they are very far

2055
01:46:09,119 --> 01:46:12,400
from they can they can be useful tools

2056
01:46:12,400 --> 01:46:16,280
they can provide and produce impressive

2057
01:46:16,280 --> 01:46:18,800
results but whether they can really be

2058
01:46:18,800 --> 01:46:21,880
called the artificial intelligence is

2059
01:46:21,880 --> 01:46:24,920
stretching the term

2060
01:46:30,000 --> 01:46:32,800
I'm so glad that industry represent same

2061
01:46:32,800 --> 01:46:35,800
things as professors but you know maybe

2062
01:46:35,800 --> 01:46:38,000
professors like you know academics what

2063
01:46:38,000 --> 01:46:40,760
do they know

2064
01:46:40,920 --> 01:46:46,000
but so very simar stand the reason why I

2065
01:46:46,000 --> 01:46:48,599
know little bit of a little bit of about

2066
01:46:48,599 --> 01:46:51,040
these things is that those list books I

2067
01:46:51,040 --> 01:46:55,159
read were uh printed by the uh Helsinki

2068
01:46:55,159 --> 01:46:56,840
University of

2069
01:46:56,840 --> 01:46:59,800
Technology U that they had some teachers

2070
01:46:59,800 --> 01:47:02,080
who were using thisis for symbolic

2071
01:47:02,080 --> 01:47:06,719
computations and uh AI research uh this

2072
01:47:06,719 --> 01:47:08,599
was I think early

2073
01:47:08,599 --> 01:47:11,520
80s last century last Millennium you

2074
01:47:11,520 --> 01:47:15,800
know many of you were born back then but

2075
01:47:15,800 --> 01:47:19,840
uh so they actually had some theoretical

2076
01:47:19,840 --> 01:47:22,159
background on that in the book

2077
01:47:22,159 --> 01:47:23,480
explaining

2078
01:47:23,480 --> 01:47:25,840
what what this is about and why that

2079
01:47:25,840 --> 01:47:29,080
kind of symbolic computation languages

2080
01:47:29,080 --> 01:47:31,320
are a good fit for that kind of problem

2081
01:47:31,320 --> 01:47:34,000
spaces or at least they are claim

2082
01:47:34,000 --> 01:47:35,199
claimed to

2083
01:47:35,199 --> 01:47:38,599
be that uh who knows because we haven't

2084
01:47:38,599 --> 01:47:42,320
actually seen real AI done with symbolic

2085
01:47:42,320 --> 01:47:43,880
computation

2086
01:47:43,880 --> 01:47:47,719
either but it's it's kind of more or

2087
01:47:47,719 --> 01:47:51,119
less a fact that mere number crunching

2088
01:47:51,119 --> 01:47:54,839
can produce intell

2089
01:47:55,719 --> 01:47:58,000
Al so we think for now but maybe it's

2090
01:47:58,000 --> 01:48:01,920
just a matter of uh kind of uh adding

2091
01:48:01,920 --> 01:48:04,400
more and more transistors into it until

2092
01:48:04,400 --> 01:48:08,000
you get Behavior sufficiently complex

2093
01:48:08,000 --> 01:48:10,880
that inventions arise out of

2094
01:48:10,880 --> 01:48:14,040
it that is

2095
01:48:14,040 --> 01:48:18,560
certainly I suppose remotely

2096
01:48:21,520 --> 01:48:24,320
PL there is questions there but I just

2097
01:48:24,320 --> 01:48:27,759
want to war that we way

2098
01:48:28,040 --> 01:48:30,920
over

2099
01:48:30,920 --> 01:48:34,239
okay yeah that wasn't a surprise but we

2100
01:48:34,239 --> 01:48:37,239
are like 15

2101
01:48:38,360 --> 01:48:39,920
minutes

2102
01:48:39,920 --> 01:48:41,760
fine we

2103
01:48:41,760 --> 01:48:45,920
started hour yeah some delay but this is

2104
01:48:45,920 --> 01:48:47,599
this is of course it's been an

2105
01:48:47,599 --> 01:48:49,440
interesting discussion considering that

2106
01:48:49,440 --> 01:48:52,880
it was really about language Technic

2107
01:48:52,880 --> 01:48:54,280
alties and then we went all

2108
01:48:54,280 --> 01:48:57,040
philosophical about various subjects I

2109
01:48:57,040 --> 01:48:59,119
don't I don't

2110
01:48:59,119 --> 01:49:02,520
mind but yeah I mean I I do need to kind

2111
01:49:02,520 --> 01:49:05,119
of give you a retroactive caveat inro

2112
01:49:05,119 --> 01:49:07,360
that I'm really not an AI Specialist or

2113
01:49:07,360 --> 01:49:08,199
an

2114
01:49:08,199 --> 01:49:11,678
expert in those

2115
01:49:11,920 --> 01:49:14,560
fields you have two questions that I can

2116
01:49:14,560 --> 01:49:16,880
access I think they're on your because

2117
01:49:16,880 --> 01:49:19,360
maybe students send them directly to in

2118
01:49:19,360 --> 01:49:23,440
the chat well this is going to be fun

2119
01:49:23,440 --> 01:49:25,719
oh

2120
01:49:26,199 --> 01:49:30,239
yeah I can see them if I stop sharing oh

2121
01:49:30,239 --> 01:49:32,400
or

2122
01:49:33,440 --> 01:49:36,719
maybe nah

2123
01:49:36,719 --> 01:49:39,520
there's no there's just commentary not

2124
01:49:39,520 --> 01:49:41,880
not

2125
01:49:46,400 --> 01:49:48,800
questions oh this one is a good one I

2126
01:49:48,800 --> 01:49:50,880
mean a large part of the purpose of any

2127
01:49:50,880 --> 01:49:52,800
programming language is to communicate

2128
01:49:52,800 --> 01:49:54,239
the meaning of the codee between

2129
01:49:54,239 --> 01:49:55,679
different

2130
01:49:55,679 --> 01:49:58,719
programmers verifying AI code is

2131
01:49:58,719 --> 01:50:01,440
understandable for others is not an easy

2132
01:50:01,440 --> 01:50:04,920
task this was a comment by our friend

2133
01:50:04,920 --> 01:50:07,239
Yar

2134
01:50:14,080 --> 01:50:17,199
ronkan the

2135
01:50:18,320 --> 01:50:23,040
clean do you mean how is it implemented

2136
01:50:23,040 --> 01:50:24,000
yeah

2137
01:50:24,000 --> 01:50:27,440
so um for online people the question

2138
01:50:27,440 --> 01:50:30,199
was in the case of exception how does

2139
01:50:30,199 --> 01:50:32,119
the cleanup actually happen how are the

2140
01:50:32,119 --> 01:50:34,440
disruptors

2141
01:50:34,440 --> 01:50:36,440
called

2142
01:50:36,440 --> 01:50:41,280
so what ends up happening is that

2143
01:50:41,280 --> 01:50:44,840
uh the compiler will generate

2144
01:50:44,840 --> 01:50:47,079
uh code that

2145
01:50:47,079 --> 01:50:50,560
manipulates a Handler table that tells

2146
01:50:50,560 --> 01:50:53,679
you where to jump that the where you

2147
01:50:53,679 --> 01:50:55,920
actually catch the exception but in

2148
01:50:55,920 --> 01:50:57,760
addition to that it's going to generate

2149
01:50:57,760 --> 01:51:01,920
cleanup records that basically tell you

2150
01:51:01,920 --> 01:51:05,760
um what cleanups need to be performed at

2151
01:51:05,760 --> 01:51:08,079
different parts of the program when an

2152
01:51:08,079 --> 01:51:09,679
exception is

2153
01:51:09,679 --> 01:51:13,800
through uh I don't know the details of

2154
01:51:13,800 --> 01:51:17,440
how this is done on Microsoft platforms

2155
01:51:17,440 --> 01:51:22,119
but in on the ium ABI meaning meaning

2156
01:51:22,119 --> 01:51:25,119
Linux and uh I would expect Mac as well

2157
01:51:25,119 --> 01:51:30,000
because they they use uh clang as a well

2158
01:51:30,000 --> 01:51:33,480
I mean Mac doesn't use elf binaries any

2159
01:51:33,480 --> 01:51:36,679
anyway on any platform that uses elf elf

2160
01:51:36,679 --> 01:51:40,520
binaries with the itanium Abbi it's done

2161
01:51:40,520 --> 01:51:43,679
so that uh you basically have debug

2162
01:51:43,679 --> 01:51:45,679
information that tracks the

2163
01:51:45,679 --> 01:51:47,760
cleanups and when you throw the

2164
01:51:47,760 --> 01:51:51,159
exception the uh program is actually

2165
01:51:51,159 --> 01:51:53,920
going to add run time interpret that

2166
01:51:53,920 --> 01:51:56,599
debug information to be able to find the

2167
01:51:56,599 --> 01:52:00,679
right kind of uh cleanups to

2168
01:52:00,679 --> 01:52:04,079
perform this is dreadfully

2169
01:52:04,079 --> 01:52:08,119
slow and the original rational for doing

2170
01:52:08,119 --> 01:52:12,320
it that way is that the uh part that we

2171
01:52:12,320 --> 01:52:14,480
ostensibly want to optimize is the

2172
01:52:14,480 --> 01:52:17,719
success part and that the error path can

2173
01:52:17,719 --> 01:52:19,159
be

2174
01:52:19,159 --> 01:52:22,880
slow but the uh slowness and overhead of

2175
01:52:22,880 --> 01:52:25,679
all that stuff by relying on debug

2176
01:52:25,679 --> 01:52:27,760
information and having to at one time

2177
01:52:27,760 --> 01:52:30,480
interpret it is a significant

2178
01:52:30,480 --> 01:52:32,760
contributor for certain audiences not

2179
01:52:32,760 --> 01:52:35,719
being able to use exceptions with

2180
01:52:35,719 --> 01:52:40,000
C++ the uh there's problems with how

2181
01:52:40,000 --> 01:52:44,199
deterministic the uh handling is and

2182
01:52:44,199 --> 01:52:47,560
just how absolutely slow it is even even

2183
01:52:47,560 --> 01:52:48,880
if it doesn't

2184
01:52:48,880 --> 01:52:52,840
fluctuate it is massively colos is

2185
01:52:52,840 --> 01:52:56,040
slower than the success path is and

2186
01:52:56,040 --> 01:52:58,679
there are various ways that it could be

2187
01:52:58,679 --> 01:53:02,760
made more efficient but there are ABI

2188
01:53:02,760 --> 01:53:06,639
compatibility aspects to consider that

2189
01:53:06,639 --> 01:53:08,880
you could you could have a new form of

2190
01:53:08,880 --> 01:53:10,639
exceptional handling but it

2191
01:53:10,639 --> 01:53:14,320
wouldn't work with all binaries and it

2192
01:53:14,320 --> 01:53:18,159
wouldn't always work with uh cross

2193
01:53:18,159 --> 01:53:20,199
language applications where you mix

2194
01:53:20,199 --> 01:53:21,280
multiple

2195
01:53:21,280 --> 01:53:24,760
languages that can actually handle uh

2196
01:53:24,760 --> 01:53:26,360
each other's

2197
01:53:26,360 --> 01:53:28,719
exception so it's

2198
01:53:28,719 --> 01:53:32,079
a that's a tricky

2199
01:53:32,079 --> 01:53:35,400
problem but yeah I mean it's basically

2200
01:53:35,400 --> 01:53:38,280
conceptually it's so that

2201
01:53:38,280 --> 01:53:41,920
uh how I mean how a normal Frame Works

2202
01:53:41,920 --> 01:53:45,520
is that you just gather the cleanups in

2203
01:53:45,520 --> 01:53:46,599
particular

2204
01:53:46,599 --> 01:53:49,520
order and then if if you jump out of it

2205
01:53:49,520 --> 01:53:52,440
with a return or break you just have the

2206
01:53:52,440 --> 01:53:54,199
the list of cleanups and then then you

2207
01:53:54,199 --> 01:53:57,480
run them but if there are cleanups in a

2208
01:53:57,480 --> 01:54:00,920
calling scope then it's not so simple

2209
01:54:00,920 --> 01:54:03,360
and uh the compiler wouldn't know how to

2210
01:54:03,360 --> 01:54:07,079
run those cleanups that in a in a manner

2211
01:54:07,079 --> 01:54:08,520
that

2212
01:54:08,520 --> 01:54:11,040
straightforward because you can you can

2213
01:54:11,040 --> 01:54:13,040
compile different translation units at

2214
01:54:13,040 --> 01:54:15,159
different times so it doesn't have the

2215
01:54:15,159 --> 01:54:18,079
visibility that's why it needs a runtime

2216
01:54:18,079 --> 01:54:21,239
it is in fact a runtime mechanism that's

2217
01:54:21,239 --> 01:54:24,679
purely runtime the compiler has no idea

2218
01:54:24,679 --> 01:54:28,000
what uh what a caller of a caller of a

2219
01:54:28,000 --> 01:54:30,440
caller needs to clean up so it does need

2220
01:54:30,440 --> 01:54:32,599
a runtime mechanism for that

2221
01:54:32,599 --> 01:54:35,800
yes and there there is such a runtime

2222
01:54:35,800 --> 01:54:38,239
mechanism and it's terribly slow at

2223
01:54:38,239 --> 01:54:43,239
least on Linux which I use on a daily

2224
01:54:43,239 --> 01:54:46,400
basis but it's it's a trade

2225
01:54:46,400 --> 01:54:49,639
of there are there are certain certain

2226
01:54:49,639 --> 01:54:51,440
other approaches like the whole

2227
01:54:51,440 --> 01:54:54,880
programming language IM is where raising

2228
01:54:54,880 --> 01:54:58,719
an error is uh lightning fast it's

2229
01:54:58,719 --> 01:55:01,760
instantaneous un common list that you

2230
01:55:01,760 --> 01:55:03,760
raise an error and jump to its Handler

2231
01:55:03,760 --> 01:55:04,719
because

2232
01:55:04,719 --> 01:55:10,040
that's done with a Handler bind that

2233
01:55:10,040 --> 01:55:13,440
basically tells the uh site of the

2234
01:55:13,440 --> 01:55:15,599
exception Throne directly where the

2235
01:55:15,599 --> 01:55:18,880
Handler is so it's bound at compile time

2236
01:55:18,880 --> 01:55:22,000
almost not quite but very close to being

2237
01:55:22,000 --> 01:55:23,360
static Al

2238
01:55:23,360 --> 01:55:26,599
bound we we don't have that ability in

2239
01:55:26,599 --> 01:55:29,960
C++ it's always always a runtime

2240
01:55:29,960 --> 01:55:34,000
operation could be uh behind an

2241
01:55:34,000 --> 01:55:36,079
arbitrarily

2242
01:55:36,079 --> 01:55:40,239
many an arbitrary amount of layers in

2243
01:55:40,239 --> 01:55:44,360
between think it's easy toate a

2244
01:55:44,360 --> 01:55:48,440
simple exception

2245
01:55:48,440 --> 01:55:52,400
SL uh

2246
01:55:52,400 --> 01:55:55,159
I mean sure if you

2247
01:55:55,159 --> 01:55:58,199
have uh it doesn't require that you you

2248
01:55:58,199 --> 01:56:00,119
just need to have a library that links

2249
01:56:00,119 --> 01:56:02,520
to a library that links to a

2250
01:56:02,520 --> 01:56:05,000
library then you have an application

2251
01:56:05,000 --> 01:56:08,480
that us uses that yeah uses that whole

2252
01:56:08,480 --> 01:56:10,840
change and then you throw from the

2253
01:56:10,840 --> 01:56:16,560
bottom most Library so I make for

2254
01:56:20,040 --> 01:56:22,840
myself yeah so so the thing is that

2255
01:56:22,840 --> 01:56:25,400
whenever you have static

2256
01:56:25,400 --> 01:56:28,079
linking the uh separate compilation

2257
01:56:28,079 --> 01:56:30,800
problems can maybe be alleviated because

2258
01:56:30,800 --> 01:56:32,840
we have link time

2259
01:56:32,840 --> 01:56:35,880
optimizations and what the equivalent of

2260
01:56:35,880 --> 01:56:38,480
what Microsoft calls link time code

2261
01:56:38,480 --> 01:56:41,119
generation it is basically link time

2262
01:56:41,119 --> 01:56:43,239
optimization same

2263
01:56:43,239 --> 01:56:47,239
difference but Dynamic loaders don't do

2264
01:56:47,239 --> 01:56:50,760
that at least not yet I wonder whether

2265
01:56:50,760 --> 01:56:53,199
they ever plan to but they don't do that

2266
01:56:53,199 --> 01:56:56,400
yet so when you do the runtime linking

2267
01:56:56,400 --> 01:56:57,520
of shared

2268
01:56:57,520 --> 01:57:00,800
libraries into a program image that then

2269
01:57:00,800 --> 01:57:04,760
runs that doesn't perform link time

2270
01:57:04,760 --> 01:57:07,320
optimizations it would be kind of neat

2271
01:57:07,320 --> 01:57:11,599
if it did but I'm unaware of a lto

2272
01:57:11,599 --> 01:57:14,880
optimizing Dynamic

2273
01:57:14,880 --> 01:57:18,280
loader but nevertheless the

2274
01:57:18,280 --> 01:57:21,480
uh the uh exception throwing mechanism

2275
01:57:21,480 --> 01:57:23,880
on certain platforms is so heavy weight

2276
01:57:23,880 --> 01:57:26,880
that you can't even optimize it it's

2277
01:57:26,880 --> 01:57:29,159
it's actively hostile to

2278
01:57:29,159 --> 01:57:33,759
optimization for for many

2279
01:57:34,520 --> 01:57:37,199
reasons I'm losing parts of the audience

2280
01:57:37,199 --> 01:57:39,598
they are

2281
01:57:44,199 --> 01:57:46,800
escaping yeah

2282
01:57:46,800 --> 01:57:49,760
sorry

2283
01:57:49,760 --> 01:57:53,280
maybe have to eat to

2284
01:57:53,280 --> 01:57:55,800
yeah but I think I think we'll be

2285
01:57:55,800 --> 01:58:00,239
calling it today thank you all

