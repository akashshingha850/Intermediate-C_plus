1
00:00:00,160 --> 00:00:03,040
cord okay okay so

2
00:00:03,040 --> 00:00:06,759
you're what do you see

3
00:00:06,759 --> 00:00:09,759
here

4
00:00:10,120 --> 00:00:13,599
okay and why did that happen okay fine

5
00:00:13,599 --> 00:00:17,280
so now I'm going to go to my

6
00:00:17,439 --> 00:00:21,279
drive and just start here

7
00:00:21,279 --> 00:00:25,439
okay so now everything should

8
00:00:25,960 --> 00:00:28,960
work let's see

9
00:00:28,960 --> 00:00:31,800
announcements

10
00:00:31,800 --> 00:00:35,399
we posted Labs that um for some reason

11
00:00:35,399 --> 00:00:38,440
one when one reason or another they were

12
00:00:38,440 --> 00:00:42,559
not part of the lectures on Tuesdays but

13
00:00:42,559 --> 00:00:45,200
uh El recorded them and they on YouTube

14
00:00:45,200 --> 00:00:47,199
so you're welcome to look at them

15
00:00:47,199 --> 00:00:50,000
invited lecture of course please come

16
00:00:50,000 --> 00:00:53,000
and um um hopefully we'll have a big

17
00:00:53,000 --> 00:00:54,399
audience for

18
00:00:54,399 --> 00:00:57,359
V we actually had a meeting with v and

19
00:00:57,359 --> 00:01:00,760
some other cute um C

20
00:01:00,760 --> 00:01:03,160
collaborators and had a great discussion

21
00:01:03,160 --> 00:01:05,438
about going forward with our

22
00:01:05,438 --> 00:01:09,240
course which um let let me just go over

23
00:01:09,240 --> 00:01:11,439
this and kind of let's reflect where are

24
00:01:11,439 --> 00:01:14,759
we we are now right here right this is

25
00:01:14,759 --> 00:01:18,520
the deadline so it seems like all of

26
00:01:18,520 --> 00:01:20,479
these assignments were not really a

27
00:01:20,479 --> 00:01:23,880
waste of your time other than raw

28
00:01:23,880 --> 00:01:26,119
pointers and raw

29
00:01:26,119 --> 00:01:30,560
arrays so uh what we're going to do in

30
00:01:30,560 --> 00:01:31,680
the

31
00:01:31,680 --> 00:01:38,079
future is uh to our plan will be to keep

32
00:01:38,079 --> 00:01:41,640
these assignments with minor changes or

33
00:01:41,640 --> 00:01:45,399
upgrad to uh take all of those R

34
00:01:45,399 --> 00:01:48,040
pointers move them to some unique or

35
00:01:48,040 --> 00:01:50,479
share depending on the situation and

36
00:01:50,479 --> 00:01:52,240
instead of arrays use whatever is

37
00:01:52,240 --> 00:01:55,040
appropriate again vors or whatever but

38
00:01:55,040 --> 00:01:57,079
they'll stay the same so this is kind of

39
00:01:57,079 --> 00:01:59,920
okay this is okay material moreover it's

40
00:01:59,920 --> 00:02:01,680
it's a great material because it does

41
00:02:01,680 --> 00:02:06,560
keep students engaged now starting here

42
00:02:06,560 --> 00:02:10,280
these two labs they are about I mean all

43
00:02:10,280 --> 00:02:13,360
of them are more related to data

44
00:02:13,360 --> 00:02:15,760
structures which is not relevant to our

45
00:02:15,760 --> 00:02:18,640
course however these two are still kind

46
00:02:18,640 --> 00:02:21,720
of okay because they teach you GDB tool

47
00:02:21,720 --> 00:02:24,720
which is important but on

48
00:02:24,720 --> 00:02:27,200
L and lab dictionary will teach you

49
00:02:27,200 --> 00:02:30,480
iterators and some um actually uh

50
00:02:30,480 --> 00:02:33,200
standard Library containers which is

51
00:02:33,200 --> 00:02:36,160
cool you implement some there which is

52
00:02:36,160 --> 00:02:39,360
again cool but again uh

53
00:02:39,360 --> 00:02:43,640
on on maybe actually lab D is fine so

54
00:02:43,640 --> 00:02:45,200
that's something we didn't discuss maybe

55
00:02:45,200 --> 00:02:47,840
that's as it is even fine but anyway

56
00:02:47,840 --> 00:02:51,680
these two Labs we could move GDB portion

57
00:02:51,680 --> 00:02:54,680
right here and maybe keep lab dictionary

58
00:02:54,680 --> 00:02:57,080
but these three otherwise would have to

59
00:02:57,080 --> 00:02:59,120
be upgraded it's something cool and we

60
00:02:59,120 --> 00:03:01,120
thinking using cute for

61
00:03:01,120 --> 00:03:04,400
animation and add some more features

62
00:03:04,400 --> 00:03:06,799
more fun features and teach future

63
00:03:06,799 --> 00:03:10,560
students not you about other things that

64
00:03:10,560 --> 00:03:14,680
are uh were the way C++ was upgraded

65
00:03:14,680 --> 00:03:18,840
later installations from uh C++ whatever

66
00:03:18,840 --> 00:03:23,319
11 at most that we see here which means

67
00:03:23,319 --> 00:03:24,680
that

68
00:03:24,680 --> 00:03:27,280
for for

69
00:03:27,280 --> 00:03:30,519
our uh lectures

70
00:03:30,519 --> 00:03:33,480
everything is kind of great except for

71
00:03:33,480 --> 00:03:34,280
this

72
00:03:34,280 --> 00:03:37,519
week where again I'm talking

73
00:03:37,519 --> 00:03:39,959
about a little irrelevant data

74
00:03:39,959 --> 00:03:42,159
structures to this

75
00:03:42,159 --> 00:03:44,879
course which is a little unfortunate

76
00:03:44,879 --> 00:03:46,239
however if I don't talk about it then

77
00:03:46,239 --> 00:03:47,879
it's harder to do that homework so I

78
00:03:47,879 --> 00:03:50,920
have to talk about how how do we arrange

79
00:03:50,920 --> 00:03:55,360
memory in link lists so and hash table

80
00:03:55,360 --> 00:03:56,879
so that it's easier for you to solve

81
00:03:56,879 --> 00:04:00,000
those problems and yet this will be

82
00:04:00,000 --> 00:04:02,599
nuked at some point and instead we'll

83
00:04:02,599 --> 00:04:05,959
have some other features of C++ more re

84
00:04:05,959 --> 00:04:09,239
recent features of C++ covering here so

85
00:04:09,239 --> 00:04:11,439
what Willer Will do is what we'll have

86
00:04:11,439 --> 00:04:13,560
to move eventually in the front of the

87
00:04:13,560 --> 00:04:15,280
course because he'll start with our role

88
00:04:15,280 --> 00:04:17,880
and shared so that's something that you

89
00:04:17,880 --> 00:04:20,959
move there all of the thir first part of

90
00:04:20,959 --> 00:04:23,840
the exercis will will be upgraded

91
00:04:23,840 --> 00:04:25,880
correspondingly so that students can

92
00:04:25,880 --> 00:04:28,400
complete them and this part of the

93
00:04:28,400 --> 00:04:30,360
course will need to be revised

94
00:04:30,360 --> 00:04:33,360
but overall what is really exciting is

95
00:04:33,360 --> 00:04:35,440
that this is

96
00:04:35,440 --> 00:04:38,280
not totally embarrassing what we are

97
00:04:38,280 --> 00:04:39,440
doing right

98
00:04:39,440 --> 00:04:42,759
now it's not and it's not totally

99
00:04:42,759 --> 00:04:45,479
relevant for you what you're learning

100
00:04:45,479 --> 00:04:48,160
it's not not at all so it's all good

101
00:04:48,160 --> 00:04:51,680
it's just not as good as it could have

102
00:04:51,680 --> 00:04:53,400
been but you know you have to start

103
00:04:53,400 --> 00:04:56,120
somewhere and this is not a bad not an

104
00:04:56,120 --> 00:04:57,440
embarrassing

105
00:04:57,440 --> 00:05:02,000
story yeah if you're saying that 9 and

106
00:05:02,000 --> 00:05:05,039
are not relevance noways will be

107
00:05:05,039 --> 00:05:07,680
included in the exam

108
00:05:07,680 --> 00:05:12,120
or I'll try to avoid that uh yeah I'll

109
00:05:12,120 --> 00:05:14,759
try to avoid that hash tables

110
00:05:14,759 --> 00:05:17,479
like they'll be included but maybe not

111
00:05:17,479 --> 00:05:19,720
link list memory I will not ask you to

112
00:05:19,720 --> 00:05:21,840
oh please create a double link list or

113
00:05:21,840 --> 00:05:23,680
triple link list that used to be

114
00:05:23,680 --> 00:05:27,280
questions on previous exams it's why why

115
00:05:27,280 --> 00:05:29,440
we instead we'll ask something about you

116
00:05:29,440 --> 00:05:30,360
know

117
00:05:30,360 --> 00:05:32,639
STL maybe and inators implemented

118
00:05:32,639 --> 00:05:33,880
interor

119
00:05:33,880 --> 00:05:36,680
something will you talk more about the

120
00:05:36,680 --> 00:05:39,000
exam on the last yes yes that's what I

121
00:05:39,000 --> 00:05:41,919
wanted to tell you that as you can see

122
00:05:41,919 --> 00:05:45,400
this is review which most likely we will

123
00:05:45,400 --> 00:05:47,400
may not have live lecture

124
00:05:47,400 --> 00:05:51,800
anymore because that's the week that I

125
00:05:51,800 --> 00:05:54,199
preparing undertaking to prepare them

126
00:05:54,199 --> 00:05:56,880
wouldn't love this um especially since

127
00:05:56,880 --> 00:05:58,720
it's going to be live it's going to be

128
00:05:58,720 --> 00:06:00,639
online only

129
00:06:00,639 --> 00:06:03,240
final exam so anybody you can take it

130
00:06:03,240 --> 00:06:04,080
from

131
00:06:04,080 --> 00:06:06,880
anywhere people will be fine home for

132
00:06:06,880 --> 00:06:09,759
that's fine uh on the airplane but the

133
00:06:09,759 --> 00:06:12,440
thing is that we really there is

134
00:06:12,440 --> 00:06:15,639
consideration coming into it you'll have

135
00:06:15,639 --> 00:06:18,120
two hours

136
00:06:18,120 --> 00:06:20,919
only because it's so Pro to TV we have

137
00:06:20,919 --> 00:06:22,560
to do something to compensate for the

138
00:06:22,560 --> 00:06:25,400
fact that it's online open book open GPT

139
00:06:25,400 --> 00:06:27,759
chat GPT anything you can use anything

140
00:06:27,759 --> 00:06:29,840
but how will we compensate going to be

141
00:06:29,840 --> 00:06:32,680
short and there's going to be a lot

142
00:06:32,680 --> 00:06:36,680
ofes so if you are

143
00:06:38,240 --> 00:06:40,639
not that's not the language that you

144
00:06:40,639 --> 00:06:43,440
really really feel now it'll be harder

145
00:06:43,440 --> 00:06:46,639
because you know feel have to all of

146
00:06:46,639 --> 00:06:48,400
those things it will take time so if you

147
00:06:48,400 --> 00:06:50,759
know it it'll be easier to answer all

148
00:06:50,759 --> 00:06:53,319
those questions so it's not unheard of

149
00:06:53,319 --> 00:06:55,360
in my other classes to have like 60

150
00:06:55,360 --> 00:06:57,240
questions on the

151
00:06:57,240 --> 00:06:59,680
exam okay so that that's how it's going

152
00:06:59,680 --> 00:07:02,199
to be because of that

153
00:07:02,199 --> 00:07:05,199
yeah

154
00:07:07,919 --> 00:07:11,520
yeah most of the

155
00:07:14,319 --> 00:07:17,960
people an interviews still uh cute

156
00:07:17,960 --> 00:07:20,160
doesn't

157
00:07:20,160 --> 00:07:22,840
use oh cute for example they don't use

158
00:07:22,840 --> 00:07:25,759
list on onor anymore but you're right

159
00:07:25,759 --> 00:07:28,479
there are many maybe questions on the

160
00:07:28,479 --> 00:07:30,960
interviews out there web that were

161
00:07:30,960 --> 00:07:32,960
concerned about list and in fact my

162
00:07:32,960 --> 00:07:34,720
mentor when she was teaching this she

163
00:07:34,720 --> 00:07:36,720
was like why are we doing this because

164
00:07:36,720 --> 00:07:38,520
of the interview questions like she

165
00:07:38,520 --> 00:07:41,280
would say that I don't think it's

166
00:07:41,280 --> 00:07:45,319
anymore the case um at least cute said

167
00:07:45,319 --> 00:07:47,960
that they don't do that and uh we had a

168
00:07:47,960 --> 00:07:50,759
couple of other

169
00:07:50,759 --> 00:07:52,919
industry colleagues I would say or

170
00:07:52,919 --> 00:07:56,080
whatever uh contacting us being upset

171
00:07:56,080 --> 00:07:58,120
with the fact that we teaching uh link

172
00:07:58,120 --> 00:08:00,800
list so it will have to

173
00:08:00,800 --> 00:08:04,039
go it's a very painful time it's like

174
00:08:04,039 --> 00:08:06,440
red flat for many people who care about

175
00:08:06,440 --> 00:08:09,400
C++ when

176
00:08:11,039 --> 00:08:13,720
we last memory it's really really

177
00:08:13,720 --> 00:08:16,039
triggers it really triggers some

178
00:08:16,039 --> 00:08:18,879
people so it has to go and the reason

179
00:08:18,879 --> 00:08:21,840
why is that C++ I think I talked about

180
00:08:21,840 --> 00:08:25,639
it C++ has this reputation of being

181
00:08:25,639 --> 00:08:27,639
maybe mishandling

182
00:08:27,639 --> 00:08:31,200
memory and uh easy to fall for unsafe

183
00:08:31,200 --> 00:08:33,880
practices so it's very important to

184
00:08:33,880 --> 00:08:36,279
teach the good practices from the start

185
00:08:36,279 --> 00:08:38,640
and you'll see what can go wrong with so

186
00:08:38,640 --> 00:08:40,958
I'll show you now and it's better just

187
00:08:40,958 --> 00:08:43,039
not to implement it and yet there will

188
00:08:43,039 --> 00:08:45,920
be always a counterargument and even in

189
00:08:45,920 --> 00:08:48,120
conversation with v yesterday it's not

190
00:08:48,120 --> 00:08:50,480
completely useless it's just a matter of

191
00:08:50,480 --> 00:08:53,000
how you balance so like when I'm going

192
00:08:53,000 --> 00:08:55,680
to spend the entire lecture on it maybe

193
00:08:55,680 --> 00:08:58,680
that's wrong balance but it may be that

194
00:08:58,680 --> 00:09:00,720
you it may as all be that you guys will

195
00:09:00,720 --> 00:09:02,680
have to implement list one day we just

196
00:09:02,680 --> 00:09:04,519
don't know so it's not a useless

197
00:09:04,519 --> 00:09:07,279
information don't think about it if we

198
00:09:07,279 --> 00:09:09,440
had all the time in our lives we would

199
00:09:09,440 --> 00:09:11,079
spend electron

200
00:09:11,079 --> 00:09:12,880
list you

201
00:09:12,880 --> 00:09:14,959
know uh it just

202
00:09:14,959 --> 00:09:19,000
like maybe just wrong proportion of of

203
00:09:19,000 --> 00:09:20,440
the

204
00:09:20,440 --> 00:09:22,800
material okay and maybe in some company

205
00:09:22,800 --> 00:09:24,200
they'll ask you questions because they

206
00:09:24,200 --> 00:09:26,920
have old interview

207
00:09:26,920 --> 00:09:30,200
questions okay so um so this is kind of

208
00:09:30,200 --> 00:09:32,800
a big picture of what's going on let's

209
00:09:32,800 --> 00:09:36,439
go let's start our

210
00:09:40,040 --> 00:09:43,279
lecture see

211
00:09:43,279 --> 00:09:47,079
what so overall let's start with a list

212
00:09:47,079 --> 00:09:49,720
an abstract data type so what is an

213
00:09:49,720 --> 00:09:52,800
abstract data type when you need some

214
00:09:52,800 --> 00:09:56,040
functionality so an abstract data type

215
00:09:56,040 --> 00:09:57,600
in general is something probably that

216
00:09:57,600 --> 00:10:00,480
you learned in um

217
00:10:00,480 --> 00:10:02,279
data structure scores how many of you

218
00:10:02,279 --> 00:10:04,040
have taken data structure scores by the

219
00:10:04,040 --> 00:10:07,360
way please read me taken you will you

220
00:10:07,360 --> 00:10:09,519
have to I think it's part of the program

221
00:10:09,519 --> 00:10:11,480
to take data structure

222
00:10:11,480 --> 00:10:14,000
okay information processing science I

223
00:10:14,000 --> 00:10:15,519
think teaches that

224
00:10:15,519 --> 00:10:18,440
first so when you take that but you

225
00:10:18,440 --> 00:10:20,360
don't have to know it it's fine we will

226
00:10:20,360 --> 00:10:22,000
not talk about this stuff that they talk

227
00:10:22,000 --> 00:10:24,279
in data structures it just like a little

228
00:10:24,279 --> 00:10:26,720
intersection right

229
00:10:26,720 --> 00:10:29,480
here say you need to implement your a

230
00:10:29,480 --> 00:10:30,920
software engineer you need to implement

231
00:10:30,920 --> 00:10:34,880
a brochure list or any kind of other

232
00:10:34,880 --> 00:10:38,360
list right then you'll be first

233
00:10:38,360 --> 00:10:40,639
concerned is what the functionality that

234
00:10:40,639 --> 00:10:43,639
you should Implement and C++ is great

235
00:10:43,639 --> 00:10:45,480
for describing functionality because you

236
00:10:45,480 --> 00:10:48,120
just give an interface to the class and

237
00:10:48,120 --> 00:10:49,600
that tells you what the list is supposed

238
00:10:49,600 --> 00:10:51,320
to do so what is it supposed to do

239
00:10:51,320 --> 00:10:53,600
you're supposed to create a list well in

240
00:10:53,600 --> 00:10:56,240
this particular interfaces you start

241
00:10:56,240 --> 00:10:58,240
with empty list and then you start

242
00:10:58,240 --> 00:11:01,360
adding elements at certain locations

243
00:11:01,360 --> 00:11:04,399
that's fine maybe you could add a

244
00:11:04,399 --> 00:11:06,680
functionality of Constructor from set of

245
00:11:06,680 --> 00:11:09,040
elements to create a list maybe or maybe

246
00:11:09,040 --> 00:11:10,959
you always just want to add elements one

247
00:11:10,959 --> 00:11:15,639
by one again a list it's a list right so

248
00:11:15,639 --> 00:11:18,440
what do you do with

249
00:11:20,279 --> 00:11:23,120
list just a collection of data that is

250
00:11:23,120 --> 00:11:25,639
in this right and you should be able to

251
00:11:25,639 --> 00:11:28,600
grab any index from any location or

252
00:11:28,600 --> 00:11:33,320
insert any any new data in at that index

253
00:11:33,320 --> 00:11:36,360
or whatever location and that's it there

254
00:11:36,360 --> 00:11:38,560
is no other functionality right so it's

255
00:11:38,560 --> 00:11:43,160
a very simple basic abstract data type

256
00:11:43,160 --> 00:11:45,320
the question is how would you implement

257
00:11:45,320 --> 00:11:49,240
plus plus even when you give this

258
00:11:49,240 --> 00:11:52,279
interface that describes functionality

259
00:11:52,279 --> 00:11:53,560
it doesn't really tell you how is

260
00:11:53,560 --> 00:11:56,240
implement the

261
00:11:56,240 --> 00:11:58,240
need and there are many ways to

262
00:11:58,240 --> 00:12:00,120
implement it so how would you store

263
00:12:00,120 --> 00:12:02,399
those documents uh those elements where

264
00:12:02,399 --> 00:12:04,560
would you lay it out in

265
00:12:04,560 --> 00:12:09,120
memory so one way is to not even bother

266
00:12:09,120 --> 00:12:13,120
and go to STD lists right list

267
00:12:13,120 --> 00:12:16,519
whatever then library has one you

268
00:12:16,519 --> 00:12:19,480
it see what's underneath how they

269
00:12:19,480 --> 00:12:22,360
implement it

270
00:12:22,360 --> 00:12:24,839
arrays not link

271
00:12:24,839 --> 00:12:28,839
memory however long time ago when there

272
00:12:28,839 --> 00:12:30,199
was not enough

273
00:12:30,199 --> 00:12:32,760
memory when you could actually run out

274
00:12:32,760 --> 00:12:33,720
of

275
00:12:33,720 --> 00:12:37,279
heat the way to implement it was linked

276
00:12:37,279 --> 00:12:41,199
memory and that's what I'll talk about

277
00:12:41,279 --> 00:12:44,000
today is this something you'll ever need

278
00:12:44,000 --> 00:12:47,079
to implement we don't know again nobody

279
00:12:47,079 --> 00:12:50,040
knows maybe but very unlikely most

280
00:12:50,040 --> 00:12:52,399
likely you'll just use STD list forever

281
00:12:52,399 --> 00:12:55,000
and you'll never need to bother with it

282
00:12:55,000 --> 00:12:57,959
if you even if you needed to implement

283
00:12:57,959 --> 00:12:59,959
this functionality probably you would

284
00:12:59,959 --> 00:13:03,680
still use arrays because again you are

285
00:13:03,680 --> 00:13:07,399
not likely to run out H memory

286
00:13:07,399 --> 00:13:10,320
any and yet here we are we'll go through

287
00:13:10,320 --> 00:13:15,000
linked memory implementation of a list

288
00:13:15,000 --> 00:13:18,760
so and the reason is homework mainly

289
00:13:18,760 --> 00:13:21,680
maybe interview questions maybe where

290
00:13:21,680 --> 00:13:23,160
did you get that information that they

291
00:13:23,160 --> 00:13:26,120
interview questions and

292
00:13:28,120 --> 00:13:31,120
linklist

293
00:13:42,399 --> 00:13:46,279
yeah so they still ask for that maybe

294
00:13:46,279 --> 00:13:48,399
they needed okay guys you know what I'm

295
00:13:48,399 --> 00:13:51,680
so glad that you said that because as I

296
00:13:51,680 --> 00:13:54,120
when I was asking around nobody ask

297
00:13:54,120 --> 00:13:56,120
questions about list anymore at cute

298
00:13:56,120 --> 00:13:58,800
they ask questions Implement payroll you

299
00:13:58,800 --> 00:14:01,800
know like something much more

300
00:14:01,800 --> 00:14:04,880
practical however I knew that 10 years

301
00:14:04,880 --> 00:14:07,320
ago Google Facebook anybody who would

302
00:14:07,320 --> 00:14:09,079
recruit our students at the University

303
00:14:09,079 --> 00:14:11,120
of Illinois they were asking this

304
00:14:11,120 --> 00:14:14,399
questions so yes some people still ask

305
00:14:14,399 --> 00:14:16,279
this questions on the interview so

306
00:14:16,279 --> 00:14:17,839
that's another motivation that I didn't

307
00:14:17,839 --> 00:14:20,120
know before this lecture good good to

308
00:14:20,120 --> 00:14:23,759
know okay so let's go it is tricky it is

309
00:14:23,759 --> 00:14:25,440
a tricky way to implement it and let's

310
00:14:25,440 --> 00:14:28,240
see how that would be implemented so we

311
00:14:28,240 --> 00:14:30,800
are talking about the new memory model

312
00:14:30,800 --> 00:14:33,399
so how is this data going to be arranged

313
00:14:33,399 --> 00:14:37,480
in memory and here is the deal we will

314
00:14:37,480 --> 00:14:41,160
have this struct that has well you know

315
00:14:41,160 --> 00:14:42,959
that struct is class public right

316
00:14:42,959 --> 00:14:44,800
everything is public there so that's

317
00:14:44,800 --> 00:14:47,360
okay so does it have data associated

318
00:14:47,360 --> 00:14:50,000
with it it's going to be one list note

319
00:14:50,000 --> 00:14:53,399
so one element on your list right so

320
00:14:53,399 --> 00:14:55,560
grocery list so it will be cabbage right

321
00:14:55,560 --> 00:14:57,560
or whatever so that's the data that

322
00:14:57,560 --> 00:14:59,800
you'll store with that element

323
00:14:59,800 --> 00:15:03,399
the pointer to the next one of the same

324
00:15:03,399 --> 00:15:07,360
kind so the linked

325
00:15:07,360 --> 00:15:09,399
item and a

326
00:15:09,399 --> 00:15:13,480
Constructor right so we would put data

327
00:15:13,480 --> 00:15:16,920
in here that's how it will be laid out

328
00:15:16,920 --> 00:15:20,160
data and a pointer sitting next to each

329
00:15:20,160 --> 00:15:22,120
other in this

330
00:15:22,120 --> 00:15:26,560
class part of for part of memory that is

331
00:15:26,560 --> 00:15:30,360
uh assigned for this class or this

332
00:15:30,360 --> 00:15:32,759
okay so what is going to be this

333
00:15:32,759 --> 00:15:35,120
declaration for example this declaration

334
00:15:35,120 --> 00:15:38,199
what is it going to

335
00:15:39,519 --> 00:15:42,759
do well you're okay with templates now

336
00:15:42,759 --> 00:15:44,959
right you're okay with templates and by

337
00:15:44,959 --> 00:15:47,319
the way I kind of brushed over it but

338
00:15:47,319 --> 00:15:50,240
what is this

339
00:15:52,480 --> 00:15:57,319
lit list item H so it's a

340
00:15:57,319 --> 00:16:00,480
template it's a temp completed Str so I

341
00:16:00,480 --> 00:16:03,680
need to just say uh like you should

342
00:16:03,680 --> 00:16:05,800
remember that it you always assume that

343
00:16:05,800 --> 00:16:07,680
it's going to be

344
00:16:07,680 --> 00:16:11,800
template type name or class lit right

345
00:16:11,800 --> 00:16:13,600
class

346
00:16:13,600 --> 00:16:17,199
lit or type name L the same thing so if

347
00:16:17,199 --> 00:16:18,959
I forget to say it like we are talking

348
00:16:18,959 --> 00:16:20,720
about templated stuff because we already

349
00:16:20,720 --> 00:16:23,279
know about templates and it's easier to

350
00:16:23,279 --> 00:16:25,639
do this so that means your list can be

351
00:16:25,639 --> 00:16:28,160
anything a list of strings list of pgs

352
00:16:28,160 --> 00:16:30,000
list of animation whatever you want to

353
00:16:30,000 --> 00:16:34,040
do fine so now I'm going to run this

354
00:16:34,040 --> 00:16:37,079
code I I have this line of code in uh

355
00:16:37,079 --> 00:16:40,839
somewhere maybe in my main I

356
00:16:40,839 --> 00:16:45,680
declare a new list

357
00:16:45,680 --> 00:16:50,399
node with I initialize it with new data

358
00:16:50,399 --> 00:16:53,440
which is an integer type so my list node

359
00:16:53,440 --> 00:16:55,759
is of integer type and it's just a

360
00:16:55,759 --> 00:16:59,800
declaration so where does n Ln live what

361
00:16:59,800 --> 00:17:02,240
does it live after

362
00:17:02,240 --> 00:17:05,280
this St

363
00:17:05,280 --> 00:17:10,000
or is an Ln is it on stack or on the

364
00:17:10,000 --> 00:17:13,679
heat stack we never ask for new stack so

365
00:17:13,679 --> 00:17:18,199
n Ln it lives on stack so these two

366
00:17:18,199 --> 00:17:21,119
things associated with the this class

367
00:17:21,119 --> 00:17:24,039
data and Nest live on stack what is the

368
00:17:24,039 --> 00:17:25,439
data for

369
00:17:25,439 --> 00:17:31,840
it five right what is the next

370
00:17:33,400 --> 00:17:36,799
pointer null or null pointer right null

371
00:17:36,799 --> 00:17:40,120
pointer that's the latest way to write

372
00:17:40,120 --> 00:17:43,080
it yes so null pointer so it's a null

373
00:17:43,080 --> 00:17:46,160
right that and it lives unstuck that's

374
00:17:46,160 --> 00:17:49,120
great okay so now let's write the code

375
00:17:49,120 --> 00:17:51,280
and I have the code here let's write the

376
00:17:51,280 --> 00:17:53,520
code to then arrange our memory like

377
00:17:53,520 --> 00:17:56,960
this instead of having it on the stack

378
00:17:56,960 --> 00:18:00,440
I'll have a little pointer on the stack

379
00:18:00,440 --> 00:18:02,559
that points to the list note on the Heap

380
00:18:02,559 --> 00:18:04,640
now so how would you ask for that let's

381
00:18:04,640 --> 00:18:07,520
call it h this it will be the head of

382
00:18:07,520 --> 00:18:10,640
our list so call it h so how do and it

383
00:18:10,640 --> 00:18:12,559
all lives on this the head the head of

384
00:18:12,559 --> 00:18:14,480
the pointer lives on the stack but the

385
00:18:14,480 --> 00:18:17,880
rest the actual

386
00:18:17,880 --> 00:18:24,640
memory the actual node lives on the how

387
00:18:27,440 --> 00:18:33,280
ask a H equals so what's its

388
00:18:37,360 --> 00:18:39,840
type yeah but for now

389
00:18:39,840 --> 00:18:42,200
integer but what do you write here

390
00:18:42,200 --> 00:18:43,400
because you have to declare and

391
00:18:43,400 --> 00:18:47,000
initialize this H and H seems to be a

392
00:18:47,000 --> 00:18:50,960
pointer to the list node right of so

393
00:18:50,960 --> 00:18:52,480
what's the type of it if it's a pointer

394
00:18:52,480 --> 00:18:53,840
to the list

395
00:18:53,840 --> 00:18:56,679
node it's a pointed to the list node

396
00:18:56,679 --> 00:19:00,039
it's this thing with an Estus

397
00:19:00,039 --> 00:19:02,840
so it's going to be list

398
00:19:02,840 --> 00:19:05,159
node

399
00:19:05,159 --> 00:19:06,799
integer

400
00:19:06,799 --> 00:19:09,960
asterisk okay and how do you ask for

401
00:19:09,960 --> 00:19:12,600
keep memory for

402
00:19:12,600 --> 00:19:15,280
that

403
00:19:15,280 --> 00:19:18,159
new and then

404
00:19:18,159 --> 00:19:23,320
what of this type so repeat

405
00:19:23,320 --> 00:19:27,760
that and then you want to initialize it

406
00:19:27,760 --> 00:19:31,760
with something so give some value

407
00:19:31,960 --> 00:19:37,640
of eight okay let's go to my code

408
00:19:37,640 --> 00:19:41,720
there let's see if that's what we're

409
00:19:43,559 --> 00:19:46,559
doing

410
00:19:47,320 --> 00:19:49,799
there is that

411
00:19:49,799 --> 00:19:52,240
good so I have a little printing

412
00:19:52,240 --> 00:19:53,640
function

413
00:19:53,640 --> 00:19:56,679
now so it will print eight if you start

414
00:19:56,679 --> 00:19:58,200
with eight my printing function is a

415
00:19:58,200 --> 00:19:59,799
recursive function that we'll talk about

416
00:19:59,799 --> 00:20:02,799
later but essentially Tak the the

417
00:20:02,799 --> 00:20:05,600
pointer that holds on to the list so far

418
00:20:05,600 --> 00:20:08,679
only one element so you can print

419
00:20:08,679 --> 00:20:10,880
everything that's attached but we have

420
00:20:10,880 --> 00:20:14,840
only one thing similarly that newless

421
00:20:14,840 --> 00:20:18,280
node on stack with five I could give an

422
00:20:18,280 --> 00:20:21,639
address of

423
00:20:22,480 --> 00:20:26,559
the of that blink no node and it would

424
00:20:26,559 --> 00:20:30,000
print the whole list starting is five so

425
00:20:30,000 --> 00:20:32,799
now I want you

426
00:20:32,799 --> 00:20:37,159
to tell me what will be the Declaration

427
00:20:37,159 --> 00:20:39,600
for

428
00:20:41,280 --> 00:20:43,960
this so I

429
00:20:43,960 --> 00:20:47,720
want and maybe the the same poter ahead

430
00:20:47,720 --> 00:20:51,640
to to now look like this so I'm going to

431
00:20:51,640 --> 00:20:53,200
just show you the code because we'll

432
00:20:53,200 --> 00:20:56,120
have an exercise later so in what I'm

433
00:20:56,120 --> 00:20:59,200
going to do I'm going to ask you have to

434
00:20:59,200 --> 00:21:01,240
ask for this memory with new someone so

435
00:21:01,240 --> 00:21:03,919
you have to have a new declaration and

436
00:21:03,919 --> 00:21:07,600
you'll have temporary T

437
00:21:07,600 --> 00:21:11,520
pointer asking for it so that's

438
00:21:11,520 --> 00:21:15,360
the Declaration for that for T it's

439
00:21:15,360 --> 00:21:18,559
going to be a pointer to the list node U

440
00:21:18,559 --> 00:21:21,360
oh in my code it's just node I'm

441
00:21:21,360 --> 00:21:25,000
sorry so just a pointer and we ask for a

442
00:21:25,000 --> 00:21:27,480
memory but now we have to connect them

443
00:21:27,480 --> 00:21:33,000
in that link list so here is the

444
00:21:33,679 --> 00:21:37,559
code initially this memory will have a

445
00:21:37,559 --> 00:21:43,159
null here so T's next will be null but

446
00:21:43,159 --> 00:21:47,960
you have to ask you have to resign it to

447
00:21:47,960 --> 00:21:52,919
be eight do you see

448
00:21:53,799 --> 00:21:57,200
that so that's what this line is

449
00:21:57,200 --> 00:22:00,080
for you have has to reassign it to be

450
00:22:00,080 --> 00:22:04,000
eight and at that point you

451
00:22:04,000 --> 00:22:08,080
have t next pointing to8 and H at that

452
00:22:08,080 --> 00:22:11,600
point still holds points to eight just

453
00:22:11,600 --> 00:22:14,159
like in this picture so the next step

454
00:22:14,159 --> 00:22:16,480
will be to Reign

455
00:22:16,480 --> 00:22:18,240
H

456
00:22:18,240 --> 00:22:21,559
2.26 which is

457
00:22:21,559 --> 00:22:24,520
what what points to set set that

458
00:22:24,520 --> 00:22:29,720
point T So H has to become t

459
00:22:29,720 --> 00:22:32,279
and then when you print it you get a

460
00:22:32,279 --> 00:22:35,000
link list six and

461
00:22:35,000 --> 00:22:38,640
E okay so now do you see what's the

462
00:22:38,640 --> 00:22:41,559
biggest problem with this things is to

463
00:22:41,559 --> 00:22:43,840
understanding what your point is forward

464
00:22:43,840 --> 00:22:47,200
and how to manage them because if you

465
00:22:47,200 --> 00:22:48,919
pre sign pointed to hold to something

466
00:22:48,919 --> 00:22:51,679
else you hope that that memory is not

467
00:22:51,679 --> 00:22:54,799
lost that you have some temporary folder

468
00:22:54,799 --> 00:22:56,840
to it or something so the biggest

469
00:22:56,840 --> 00:23:00,600
problem is to manage this handlers to

470
00:23:00,600 --> 00:23:02,559
dynamic memory because dynamic memory

471
00:23:02,559 --> 00:23:05,440
doesn't have a name you only hold it

472
00:23:05,440 --> 00:23:07,360
through stack

473
00:23:07,360 --> 00:23:11,400
pointers and you have to be careful so I

474
00:23:11,400 --> 00:23:14,159
have the next assignment and I want to

475
00:23:14,159 --> 00:23:17,039
reduce this drawing on slides instead

476
00:23:17,039 --> 00:23:21,279
I'll ask you to maybe you know draw or

477
00:23:21,279 --> 00:23:25,880
think about this question so now in my

478
00:23:25,880 --> 00:23:29,679
code I have this

479
00:23:29,679 --> 00:23:31,320
I guess I still have to kind of draw a

480
00:23:31,320 --> 00:23:34,439
little bit I have this

481
00:23:34,799 --> 00:23:37,120
nln go

482
00:23:37,120 --> 00:23:42,440
back I have this new list note on stack

483
00:23:42,440 --> 00:23:46,440
and I have the H pointer on stack as

484
00:23:46,440 --> 00:23:48,919
well everything else on

485
00:23:48,919 --> 00:23:54,720
Heap so H is this T still points here I

486
00:23:54,720 --> 00:23:57,600
guess you can use it if you want or not

487
00:23:57,600 --> 00:23:59,880
t also lives on the stack by the way so

488
00:23:59,880 --> 00:24:03,000
let's draw it better T is

489
00:24:03,000 --> 00:24:05,840
temporary pointer also pointing to six

490
00:24:05,840 --> 00:24:09,000
so that's your memory Arrangement what I

491
00:24:09,000 --> 00:24:10,600
want to

492
00:24:10,600 --> 00:24:14,840
have is I want to add five to this list

493
00:24:14,840 --> 00:24:17,240
so I want you to give me the code that

494
00:24:17,240 --> 00:24:20,520
would do this

495
00:24:23,640 --> 00:24:28,440
one so the head or age points to five

496
00:24:28,440 --> 00:24:30,799
and Five Points to six and six points

497
00:24:30,799 --> 00:24:36,799
to8 and you have an or like um

498
00:24:36,799 --> 00:24:40,480
ordered so which one of these a b c and

499
00:24:40,480 --> 00:24:43,919
d are

500
00:24:43,919 --> 00:24:47,240
the is the correct code to accomplish

501
00:24:47,240 --> 00:24:51,200
that and we can go here so you can try

502
00:24:51,200 --> 00:24:53,880
to figure it

503
00:24:57,320 --> 00:25:00,320
out

504
00:25:01,480 --> 00:25:04,360
this or this

505
00:25:07,520 --> 00:25:12,360
A or B or C or

506
00:25:12,559 --> 00:25:15,120
D I think there's other ways like you

507
00:25:15,120 --> 00:25:17,880
could say something else you could use T

508
00:25:17,880 --> 00:25:20,880
still I think with your temporary thing

509
00:25:20,880 --> 00:25:24,679
to to make

510
00:25:24,679 --> 00:25:27,320
reassignments C is

511
00:25:27,320 --> 00:25:30,320
winning

512
00:25:38,000 --> 00:25:41,480
H or

513
00:25:42,240 --> 00:25:44,600
a and that's how your understand

514
00:25:44,600 --> 00:25:47,640
questions will look so if you go through

515
00:25:47,640 --> 00:25:50,279
lectures and look at this slider that

516
00:25:50,279 --> 00:25:52,520
come questions that's the way we'll be

517
00:25:52,520 --> 00:25:56,039
doing this except there will be always

518
00:25:56,039 --> 00:25:59,320
at least six choices again so

519
00:25:59,320 --> 00:26:02,120
that so that it's harder to cheat harder

520
00:26:02,120 --> 00:26:04,399
to know harder to you know so that's

521
00:26:04,399 --> 00:26:06,959
less time

522
00:26:11,840 --> 00:26:16,760
to a or C A or C should we go to the

523
00:26:16,760 --> 00:26:19,679
compiler so tell me start telling me

524
00:26:19,679 --> 00:26:24,120
what is it I want to print eight and

525
00:26:24,120 --> 00:26:27,919
have five eight instead right so tell me

526
00:26:27,919 --> 00:26:30,640
what's the first

527
00:26:36,240 --> 00:26:43,000
line next equals to oh is it nln yeah NL

528
00:26:43,000 --> 00:26:46,159
nln of course I cannot do this because

529
00:26:46,159 --> 00:26:48,320
that will that's not a pointer so we

530
00:26:48,320 --> 00:26:52,320
have only dot next equals

531
00:26:52,320 --> 00:26:54,760
to8

532
00:26:54,760 --> 00:26:57,240
good equals

533
00:26:57,240 --> 00:26:59,039
to

534
00:26:59,039 --> 00:27:02,559
is it nln because it say A or B your

535
00:27:02,559 --> 00:27:05,919
compil will be your friend nln

536
00:27:05,919 --> 00:27:10,760
type is node integer H type is node

537
00:27:10,760 --> 00:27:12,720
pointer you can assign one to another

538
00:27:12,720 --> 00:27:16,159
how you have to take the address of

539
00:27:16,159 --> 00:27:20,159
nlm okay let's see 568 so that's uh is

540
00:27:20,159 --> 00:27:21,440
it A or

541
00:27:21,440 --> 00:27:27,159
B it's the a yeah a wins the team a wins

542
00:27:27,159 --> 00:27:31,399
good okay so now we have this

543
00:27:31,399 --> 00:27:33,399
interesting Arrangement right so what do

544
00:27:33,399 --> 00:27:36,440
we have let's draw this um stuff and in

545
00:27:36,440 --> 00:27:38,320
the meantime you tell me what's wrong

546
00:27:38,320 --> 00:27:41,000
with this code so we have the

547
00:27:41,000 --> 00:27:44,240
H here on the stack so everything this

548
00:27:44,240 --> 00:27:49,440
is stack this is Heap H points

549
00:27:49,640 --> 00:27:52,880
to this nln which still has the name and

550
00:27:52,880 --> 00:27:55,720
it still lives in stack right so the

551
00:27:55,720 --> 00:27:58,480
address of H the value of pointer h is

552
00:27:58,480 --> 00:28:00,840
the address on the stack that's fine

553
00:28:00,840 --> 00:28:03,320
which is five and then the next pointer

554
00:28:03,320 --> 00:28:06,840
the pointer uh that is the next element

555
00:28:06,840 --> 00:28:11,159
of that class node points to

556
00:28:11,159 --> 00:28:14,919
six and six points to eight and I think

557
00:28:14,919 --> 00:28:17,159
T still lives on stack and still points

558
00:28:17,159 --> 00:28:19,440
to six we can change that okay so that's

559
00:28:19,440 --> 00:28:21,360
your that's your Arrangement what's

560
00:28:21,360 --> 00:28:23,279
wrong with it what's wrong with this

561
00:28:23,279 --> 00:28:24,880
Arrangement and what's wrong with the

562
00:28:24,880 --> 00:28:29,080
code like what happens once the main

563
00:28:29,080 --> 00:28:33,559
code the main function stops its

564
00:28:35,200 --> 00:28:36,960
execution yeah

565
00:28:36,960 --> 00:28:41,440
memory what is it leak Le this we didn't

566
00:28:41,440 --> 00:28:43,640
give it back to he we have to explicitly

567
00:28:43,640 --> 00:28:46,559
say delete if we ask for new so we asked

568
00:28:46,559 --> 00:28:49,840
for new twice we didn't call delete so

569
00:28:49,840 --> 00:28:53,519
okay memory leak what else is

570
00:28:54,600 --> 00:28:57,519
wrong so now you have this link memory

571
00:28:57,519 --> 00:29:00,120
and some it is on the stack some of it

572
00:29:00,120 --> 00:29:02,039
is in the Heap what if you want to clear

573
00:29:02,039 --> 00:29:05,039
it all out as a function of your list

574
00:29:05,039 --> 00:29:07,080
how will that function once it takes

575
00:29:07,080 --> 00:29:09,799
this memory with the point pointing to

576
00:29:09,799 --> 00:29:12,000
the first element how does it know that

577
00:29:12,000 --> 00:29:14,200
that first element lives on the stack or

578
00:29:14,200 --> 00:29:15,679
maybe the third one will live on the

579
00:29:15,679 --> 00:29:19,960
step if you connect this L these nodes

580
00:29:19,960 --> 00:29:22,640
that some of them are on the Heap and

581
00:29:22,640 --> 00:29:25,159
some of them are on the stack this

582
00:29:25,159 --> 00:29:27,440
potentially opens the door for huge

583
00:29:27,440 --> 00:29:28,600
disaster

584
00:29:28,600 --> 00:29:31,840
because once you pass that list to some

585
00:29:31,840 --> 00:29:34,760
function there is no programmatic way in

586
00:29:34,760 --> 00:29:37,880
C++ to know if any variable is on the

587
00:29:37,880 --> 00:29:39,640
stack or on

588
00:29:39,640 --> 00:29:43,799
he so if that program clear list we want

589
00:29:43,799 --> 00:29:46,960
to clear all or delete all elements

590
00:29:46,960 --> 00:29:48,679
it'll try to delete something on the

591
00:29:48,679 --> 00:29:53,600
stack and that's a problem so it's a bad

592
00:29:53,600 --> 00:29:56,880
design choice to mix

593
00:29:56,880 --> 00:29:58,640
up uh

594
00:29:58,640 --> 00:30:01,679
stack nodes with Heap noes and attach

595
00:30:01,679 --> 00:30:04,039
them all in this

596
00:30:04,039 --> 00:30:06,519
Arrangement okay so that's one problem

597
00:30:06,519 --> 00:30:08,519
another one is memory leak right how

598
00:30:08,519 --> 00:30:10,159
could you find out that there's a memory

599
00:30:10,159 --> 00:30:12,960
leak oh let's see we would go to

600
00:30:12,960 --> 00:30:16,440
solution so what's good about God bolt

601
00:30:16,440 --> 00:30:19,120
is that you can put

602
00:30:19,120 --> 00:30:22,320
the you can put the flags for your

603
00:30:22,320 --> 00:30:25,679
compiler so F sanitize would say well

604
00:30:25,679 --> 00:30:28,240
you know you have this memory arange

605
00:30:28,240 --> 00:30:30,600
that's great but you leave memory so we

606
00:30:30,600 --> 00:30:31,960
know how to use

607
00:30:31,960 --> 00:30:33,799
sanitizer that's

608
00:30:33,799 --> 00:30:37,320
cool however if you started working with

609
00:30:37,320 --> 00:30:40,880
this list and passing it by AG and you

610
00:30:40,880 --> 00:30:44,039
have that one note on the stack to any

611
00:30:44,039 --> 00:30:46,960
other if any other function would try to

612
00:30:46,960 --> 00:30:48,399
delete that memory you would have

613
00:30:48,399 --> 00:30:51,880
another link or moment

614
00:30:51,880 --> 00:30:55,840
problem okay so don't do that we don't

615
00:30:55,840 --> 00:30:59,159
do that right we we will not ever link

616
00:30:59,159 --> 00:31:01,919
this kind of nodes in the list we'll

617
00:31:01,919 --> 00:31:04,480
only use

618
00:31:04,799 --> 00:31:07,480
pointers okay

619
00:31:07,480 --> 00:31:11,559
good oh yeah what's the big problem I

620
00:31:11,559 --> 00:31:13,399
was supposed to ask you but you already

621
00:31:13,399 --> 00:31:16,720
answered that there's a memory leak good

622
00:31:16,720 --> 00:31:19,200
now let's talk about clear function so

623
00:31:19,200 --> 00:31:21,639
now again we assume that this clear

624
00:31:21,639 --> 00:31:25,000
function will never ever ever

625
00:31:25,000 --> 00:31:28,399
take like this pointer will not have any

626
00:31:28,399 --> 00:31:32,678
your really no noes on the

627
00:31:32,840 --> 00:31:36,399
St that's a big

628
00:31:36,480 --> 00:31:39,799
assumption which one is correct so now

629
00:31:39,799 --> 00:31:45,399
in this clear function you get the head

630
00:31:45,399 --> 00:31:49,200
pointer and you want to clear all of the

631
00:31:49,200 --> 00:31:51,320
memory because we don't want to have a

632
00:31:51,320 --> 00:31:55,399
memory leak right so please

633
00:31:55,399 --> 00:31:59,840
pick what's the correct clear function

634
00:32:07,279 --> 00:32:12,600
and I can uh so sorry I'll I'll go

635
00:32:12,600 --> 00:32:15,480
to I guess I only have solution here

636
00:32:15,480 --> 00:32:19,159
hold on I'll go to

637
00:32:19,240 --> 00:32:22,240
solution why can't I go to okay and now

638
00:32:22,240 --> 00:32:24,639
I go back to so you can still keep

639
00:32:24,639 --> 00:32:28,799
answering B is the answer let's look

640
00:32:28,799 --> 00:32:31,000
what's the difference here do you see

641
00:32:31,000 --> 00:32:33,880
when I pass the head

642
00:32:33,880 --> 00:32:37,880
pointer I can pass it by reference or by

643
00:32:37,880 --> 00:32:40,919
value what is that passing a pointer by

644
00:32:40,919 --> 00:32:43,240
reference does that kind of like seems

645
00:32:43,240 --> 00:32:45,639
like oh my God what's happening there

646
00:32:45,639 --> 00:32:48,240
right so let's make it absolutely clear

647
00:32:48,240 --> 00:32:50,240
because it turns out it's

648
00:32:50,240 --> 00:32:52,360
crucial and that's why interview

649
00:32:52,360 --> 00:32:55,080
questions are so tricky because of that

650
00:32:55,080 --> 00:32:56,840
pass and those by reference sometimes it

651
00:32:56,840 --> 00:32:58,639
will work and sometimes it it will not

652
00:32:58,639 --> 00:33:00,360
and let's make sure we totally

653
00:33:00,360 --> 00:33:02,120
understand what's going on here so as

654
00:33:02,120 --> 00:33:04,240
you can see there's Choice by reference

655
00:33:04,240 --> 00:33:07,960
or by value of the head pointer and

656
00:33:07,960 --> 00:33:11,799
after that it's just a matter of when do

657
00:33:11,799 --> 00:33:13,360
you call the

658
00:33:13,360 --> 00:33:16,960
recursion again recursion is always

659
00:33:16,960 --> 00:33:21,039
tricky so so B seems to be the answer

660
00:33:21,039 --> 00:33:22,720
for we have four people who are trying

661
00:33:22,720 --> 00:33:25,440
to answer so B okay let's Trace B and

662
00:33:25,440 --> 00:33:28,600
see that we understand fine so here is

663
00:33:28,600 --> 00:33:32,840
the head pointer it's passed by

664
00:33:32,840 --> 00:33:36,639
reference what does it mean so when you

665
00:33:36,639 --> 00:33:39,880
call clear H and you pass H to that

666
00:33:39,880 --> 00:33:43,080
function and remember H is on stack

667
00:33:43,080 --> 00:33:44,880
everything else is on the

668
00:33:44,880 --> 00:33:49,159
Heap and you say okay head is the new

669
00:33:49,159 --> 00:33:53,279
name for that pointer so we don't keep

670
00:33:53,279 --> 00:33:57,799
it as a separate element we just say oh

671
00:33:57,799 --> 00:33:59,399
for this function that we are about to

672
00:33:59,399 --> 00:34:02,200
enter this clear function the stack of

673
00:34:02,200 --> 00:34:04,480
clear function let's draw it explicitly

674
00:34:04,480 --> 00:34:07,120
this is the stack of clear function

675
00:34:07,120 --> 00:34:08,839
there will be

676
00:34:08,839 --> 00:34:11,199
head but it will not be a separate

677
00:34:11,199 --> 00:34:13,520
element it will be actually the same

678
00:34:13,520 --> 00:34:16,239
name it's a different name for the same

679
00:34:16,239 --> 00:34:22,480
pointer but it just in the scope of that

680
00:34:22,480 --> 00:34:25,719
function that is still the same name

681
00:34:25,719 --> 00:34:28,440
that previous po

682
00:34:28,440 --> 00:34:30,719
okay which means that if we're going to

683
00:34:30,719 --> 00:34:34,079
change it h is going to change as

684
00:34:34,079 --> 00:34:37,440
well and are we G to is Our intention to

685
00:34:37,440 --> 00:34:39,440
change

686
00:34:39,440 --> 00:34:43,040
age is it or not what do we want let's

687
00:34:43,040 --> 00:34:46,079
ask our question what do you want to

688
00:34:46,079 --> 00:34:50,399
have after we St what is the result of

689
00:34:50,399 --> 00:34:53,800
this function what do you want H to

690
00:34:53,800 --> 00:34:59,640
hold how should H look like

691
00:34:59,720 --> 00:35:02,599
here where should it look where should

692
00:35:02,599 --> 00:35:04,960
it point

693
00:35:04,960 --> 00:35:07,960
to origin at the beginning before that

694
00:35:07,960 --> 00:35:11,160
line it points to the list after you

695
00:35:11,160 --> 00:35:13,599
clear it it should be null so you really

696
00:35:13,599 --> 00:35:15,880
really want to change H you want to

697
00:35:15,880 --> 00:35:17,160
change the memory address that it's

698
00:35:17,160 --> 00:35:20,000
holding in the beginning before calling

699
00:35:20,000 --> 00:35:22,839
the function to null therefore you have

700
00:35:22,839 --> 00:35:26,480
to pass it by reference because if you

701
00:35:26,480 --> 00:35:28,280
don't then

702
00:35:28,280 --> 00:35:30,960
then this variable will get the value

703
00:35:30,960 --> 00:35:32,520
null that you want to but you really

704
00:35:32,520 --> 00:35:35,320
want to change age so you want them to

705
00:35:35,320 --> 00:35:37,880
be the

706
00:35:38,760 --> 00:35:42,880
same that's why you pass it by

707
00:35:42,880 --> 00:35:45,800
reference okay and this will accomplish

708
00:35:45,800 --> 00:35:48,000
it so therefore this is just incorrect

709
00:35:48,000 --> 00:35:51,680
we know that that aftering this function

710
00:35:51,680 --> 00:35:53,680
H cannot be

711
00:35:53,680 --> 00:35:56,560
changed head will be changed but not H

712
00:35:56,560 --> 00:35:59,599
right so this this is not true now the

713
00:35:59,599 --> 00:36:02,079
question is how what's the order of it

714
00:36:02,079 --> 00:36:03,720
of course there's always possibility

715
00:36:03,720 --> 00:36:05,839
that I made a tricky question which is

716
00:36:05,839 --> 00:36:08,400
still fair I think that none of this is

717
00:36:08,400 --> 00:36:10,839
corre so the part of the exam there will

718
00:36:10,839 --> 00:36:15,440
be there will be answers e so um please

719
00:36:15,440 --> 00:36:17,839
make sure that you fully understand your

720
00:36:17,839 --> 00:36:21,359
answer um because it maybe that none of

721
00:36:21,359 --> 00:36:23,359
the answers none of the choices are

722
00:36:23,359 --> 00:36:25,800
correct so let's see what this function

723
00:36:25,800 --> 00:36:28,040
accomplished it says okay if head is

724
00:36:28,040 --> 00:36:30,720
still not a null pointer well it's not

725
00:36:30,720 --> 00:36:34,560
originally then call recursion which

726
00:36:34,560 --> 00:36:39,000
means that go recursively on the next

727
00:36:39,000 --> 00:36:41,760
element so take this pointer go

728
00:36:41,760 --> 00:36:44,760
recursively here that will be the next

729
00:36:44,760 --> 00:36:48,200
clear function so if this is clear one

730
00:36:48,200 --> 00:36:53,118
clear one this is clear two call

731
00:36:53,200 --> 00:36:57,160
right and then if they and this is now

732
00:36:57,160 --> 00:36:58,040
the head

733
00:36:58,040 --> 00:37:01,640
head the the different name for

734
00:37:01,640 --> 00:37:04,880
that uh variable that's on the Heap will

735
00:37:04,880 --> 00:37:08,720
be had in that in the scope of clear

736
00:37:08,720 --> 00:37:12,240
two so then we go inside of clear two

737
00:37:12,240 --> 00:37:14,240
and we check if head is null pointer

738
00:37:14,240 --> 00:37:17,480
it's not so then we go

739
00:37:17,480 --> 00:37:21,440
recursively in clear three function and

740
00:37:21,440 --> 00:37:24,160
head is different name for this pointer

741
00:37:24,160 --> 00:37:25,160
which is

742
00:37:25,160 --> 00:37:27,720
null and if it's null clear that does

743
00:37:27,720 --> 00:37:31,480
nothing so we return to the scope of the

744
00:37:31,480 --> 00:37:36,200
previous recursor call where had um was

745
00:37:36,200 --> 00:37:38,880
pointing to eight so what do we do after

746
00:37:38,880 --> 00:37:42,960
we exit the recursive call we delete we

747
00:37:42,960 --> 00:37:46,960
free this memory and assign it to

748
00:37:46,960 --> 00:37:51,319
null head to null and then we go back

749
00:37:51,319 --> 00:37:54,560
here we delete this memory and assign

750
00:37:54,560 --> 00:37:55,520
ahe to

751
00:37:55,520 --> 00:37:58,040
null and that's it

752
00:37:58,040 --> 00:38:00,240
so yes this is the correct function why

753
00:38:00,240 --> 00:38:03,119
is this not correct it first deletes

754
00:38:03,119 --> 00:38:05,200
whatever is the pointer and then goes

755
00:38:05,200 --> 00:38:07,839
recursively on what seems to be null

756
00:38:07,839 --> 00:38:11,119
which is SEC fault right away right so

757
00:38:11,119 --> 00:38:13,319
fortunately we can the reference null so

758
00:38:13,319 --> 00:38:17,319
this is a very easy mistake to to

759
00:38:17,319 --> 00:38:21,480
detect okay so where's our code

760
00:38:21,480 --> 00:38:23,119
hopefully that's what it does it says

761
00:38:23,119 --> 00:38:26,440
clear so after we clear

762
00:38:26,440 --> 00:38:28,880
h look what we are

763
00:38:28,880 --> 00:38:32,680
printing we are printing the H value

764
00:38:32,680 --> 00:38:34,920
that right

765
00:38:34,920 --> 00:38:38,520
there um let me just remove this so that

766
00:38:38,520 --> 00:38:40,480
clear function looks just like yours no

767
00:38:40,480 --> 00:38:43,440
Printing and then you can see that

768
00:38:43,440 --> 00:38:47,000
this print printing statement for the

769
00:38:47,000 --> 00:38:52,440
pointer H would result in zero which is

770
00:38:52,440 --> 00:38:55,319
null and just to make sure that if you

771
00:38:55,319 --> 00:38:58,040
didn't pass a

772
00:38:58,040 --> 00:38:58,920
by

773
00:38:58,920 --> 00:39:02,960
reference you would get this what is

774
00:39:02,960 --> 00:39:05,560
that please explain what is going on

775
00:39:05,560 --> 00:39:08,050
this what

776
00:39:08,050 --> 00:39:12,240
[Music]

777
00:39:12,240 --> 00:39:14,760
happened well you didn't pass it by

778
00:39:14,760 --> 00:39:18,280
reference which means that H never got

779
00:39:18,280 --> 00:39:21,800
to be the null value and you try to

780
00:39:21,800 --> 00:39:24,200
print it the print function do

781
00:39:24,200 --> 00:39:26,800
references memory that doesn't belong to

782
00:39:26,800 --> 00:39:28,760
you anymore more you have a dentling

783
00:39:28,760 --> 00:39:31,400
pointer right here you you thought you

784
00:39:31,400 --> 00:39:34,160
cleared AG which you did you freed all

785
00:39:34,160 --> 00:39:37,440
of the memory but H itself is a d point

786
00:39:37,440 --> 00:39:39,200
because you didn't passil so it's not

787
00:39:39,200 --> 00:39:40,920
null which means that you can try to

788
00:39:40,920 --> 00:39:42,920
print it you can try to reference it and

789
00:39:42,920 --> 00:39:45,520
go somewhere you're not supposed to

790
00:39:45,520 --> 00:39:48,000
hence the arrow right so that's why you

791
00:39:48,000 --> 00:39:51,880
can see how just that little thing ERS

792
00:39:51,880 --> 00:39:53,800
fites the

793
00:39:53,800 --> 00:39:58,520
whole uh problem okay so what's the

794
00:39:58,520 --> 00:40:03,040
correct code then B is correct a is

795
00:40:03,040 --> 00:40:06,079
not but for other reason see oh yeah

796
00:40:06,079 --> 00:40:08,680
sorry a is a is this one yeah exactly

797
00:40:08,680 --> 00:40:11,800
for that reason Okay cool so you can see

798
00:40:11,800 --> 00:40:14,720
how fun it is right it's all very tricky

799
00:40:14,720 --> 00:40:16,640
because there's recursion and there's

800
00:40:16,640 --> 00:40:19,400
passing pointers by reference so let's

801
00:40:19,400 --> 00:40:21,640
try to

802
00:40:21,640 --> 00:40:25,480
insert an element of this value so this

803
00:40:25,480 --> 00:40:28,880
is the data in instead of this element

804
00:40:28,880 --> 00:40:31,400
of the list so you give this function

805
00:40:31,400 --> 00:40:34,440
the element of the list and you want the

806
00:40:34,440 --> 00:40:36,480
new data coming to there and this guy

807
00:40:36,480 --> 00:40:38,440
shift essentially right so you want to

808
00:40:38,440 --> 00:40:41,160
insert an ele an

809
00:40:41,160 --> 00:40:43,240
element in the

810
00:40:43,240 --> 00:40:46,400
list so you can see that here I try to

811
00:40:46,400 --> 00:40:47,960
insert

812
00:40:47,960 --> 00:40:51,720
seven instead of H next what is h next

813
00:40:51,720 --> 00:40:53,760
if this is H and this is H nextest so

814
00:40:53,760 --> 00:40:56,640
instead of eight I want to insert seven

815
00:40:56,640 --> 00:41:00,599
here so I want the memory look like that

816
00:41:00,599 --> 00:41:04,160
afterwards after this line and I want to

817
00:41:04,160 --> 00:41:08,200
insert five and hopefully five is in all

818
00:41:08,200 --> 00:41:10,200
right right we don't have that on the

819
00:41:10,200 --> 00:41:12,079
stat five anymore I want to insert a new

820
00:41:12,079 --> 00:41:16,319
element five right here instead of H so

821
00:41:16,319 --> 00:41:20,640
H should be pointing now to

822
00:41:20,640 --> 00:41:24,400
five instead of six

823
00:41:24,400 --> 00:41:27,720
right so a since H points to six I wants

824
00:41:27,720 --> 00:41:31,599
to insert five instead of six and shift

825
00:41:31,599 --> 00:41:34,839
six forward so after these two lines my

826
00:41:34,839 --> 00:41:38,520
list should be 5 6 7

827
00:41:39,280 --> 00:41:42,319
8 what's the correct code for that and

828
00:41:42,319 --> 00:41:46,680
let me click on a solution so that we

829
00:41:47,079 --> 00:41:51,000
can look at it later

830
00:41:51,000 --> 00:41:53,960
but let me

831
00:41:53,960 --> 00:41:57,599
go give it to you what's the correct

832
00:41:57,599 --> 00:42:00,960
implementation of

833
00:42:04,599 --> 00:42:07,760
insert right I forgot to put answers ABC

834
00:42:07,760 --> 00:42:09,119
d right

835
00:42:09,119 --> 00:42:10,760
here

836
00:42:10,760 --> 00:42:13,079
D let's look at the

837
00:42:13,079 --> 00:42:15,720
differences again there

838
00:42:15,720 --> 00:42:18,720
is how do you pass your value the

839
00:42:18,720 --> 00:42:21,880
pointer to the current element is it by

840
00:42:21,880 --> 00:42:24,000
value or by

841
00:42:24,000 --> 00:42:27,599
reference and after that obviously you

842
00:42:27,599 --> 00:42:29,480
need to ask for new node right because

843
00:42:29,480 --> 00:42:32,599
you'll be inserting this node with data

844
00:42:32,599 --> 00:42:35,040
so that's okay that's always number

845
00:42:35,040 --> 00:42:38,440
one but then the order at which you will

846
00:42:38,440 --> 00:42:39,839
reassign

847
00:42:39,839 --> 00:42:41,880
thisle this

848
00:42:41,880 --> 00:42:44,440
pointers is going to be the problem da

849
00:42:44,440 --> 00:42:48,880
AA okay we have kind of the same split

850
00:42:50,920 --> 00:42:55,119
again so D or a d or a let's look at the

851
00:42:55,119 --> 00:42:58,240
code and you tell me

852
00:42:58,240 --> 00:43:00,520
is it D or

853
00:43:00,520 --> 00:43:04,559
a d right is that what's the difference

854
00:43:04,559 --> 00:43:06,119
between D or

855
00:43:06,119 --> 00:43:10,319
a just passing by

856
00:43:10,319 --> 00:43:12,960
reference so again just passing by

857
00:43:12,960 --> 00:43:15,200
reference so why is

858
00:43:15,200 --> 00:43:19,040
that why is it crucial that you pass by

859
00:43:19,040 --> 00:43:20,559
reference let's see what happens if you

860
00:43:20,559 --> 00:43:23,280
don't pass by

861
00:43:23,640 --> 00:43:27,599
reference it just doesn't insert it why

862
00:43:27,599 --> 00:43:28,559
is

863
00:43:28,559 --> 00:43:32,359
that let's see let's look at my code

864
00:43:32,359 --> 00:43:33,319
here

865
00:43:33,319 --> 00:43:36,680
back so when you pass

866
00:43:36,680 --> 00:43:40,040
H let's start with this it's easier

867
00:43:40,040 --> 00:43:42,119
because it's the head one the front

868
00:43:42,119 --> 00:43:46,079
one do you expect H to change after the

869
00:43:46,079 --> 00:43:49,040
call of this

870
00:43:49,720 --> 00:43:53,079
function do you expect H to change after

871
00:43:53,079 --> 00:43:56,160
the go where does H point to what's this

872
00:43:56,160 --> 00:43:57,920
H value

873
00:43:57,920 --> 00:44:01,520
H is a pointer so what's its

874
00:44:01,520 --> 00:44:04,680
value the address of

875
00:44:04,680 --> 00:44:08,640
six what do you want it to be

876
00:44:08,640 --> 00:44:11,880
afterwards the address of five it has to

877
00:44:11,880 --> 00:44:13,960
change so if you pass it it has to

878
00:44:13,960 --> 00:44:16,440
change which means that you have to pass

879
00:44:16,440 --> 00:44:18,200
it by

880
00:44:18,200 --> 00:44:22,119
reference otherwise this curve element

881
00:44:22,119 --> 00:44:24,480
whatever Curve will be this curve

882
00:44:24,480 --> 00:44:26,680
element will be completely different

883
00:44:26,680 --> 00:44:30,839
only in the scope of this function and

884
00:44:30,839 --> 00:44:33,559
that Cur will point to five and then to

885
00:44:33,559 --> 00:44:35,920
six but H will not be

886
00:44:35,920 --> 00:44:39,599
changed unless you say that c is the

887
00:44:39,599 --> 00:44:42,359
same name as

888
00:44:42,359 --> 00:44:46,640
H okay cool

889
00:44:46,640 --> 00:44:50,599
right fine fine fine fine very

890
00:44:50,599 --> 00:44:54,960
good again the same trick same trick py

891
00:44:54,960 --> 00:44:57,160
right but you would think that all all

892
00:44:57,160 --> 00:44:59,599
of the functions then have to pass

893
00:44:59,599 --> 00:45:02,280
things in L list by reference and that's

894
00:45:02,280 --> 00:45:04,720
not true

895
00:45:04,720 --> 00:45:07,400
either now let's print function let's

896
00:45:07,400 --> 00:45:10,440
write printing so I have I initialize

897
00:45:10,440 --> 00:45:14,200
this this H and say h is now still this

898
00:45:14,200 --> 00:45:17,240
list maybe I have now five and seven but

899
00:45:17,240 --> 00:45:19,000
maybe just this doesn't matter whatever

900
00:45:19,000 --> 00:45:21,839
H is I want to print

901
00:45:21,839 --> 00:45:24,160
it and you've seen that I printed it

902
00:45:24,160 --> 00:45:25,960
successfully so which one of these

903
00:45:25,960 --> 00:45:30,800
functions was the solution so let me go

904
00:45:30,800 --> 00:45:33,000
to the

905
00:45:33,000 --> 00:45:38,079
solution and uh let me open

906
00:45:41,520 --> 00:45:45,480
this what's the difference in this

907
00:45:45,480 --> 00:45:48,000
functions again

908
00:45:48,000 --> 00:45:52,240
passing the the head of the list by

909
00:45:52,240 --> 00:45:56,400
reference or by value that's okay second

910
00:45:56,400 --> 00:45:59,440
difference is is that this one these two

911
00:45:59,440 --> 00:46:02,000
functions are not recursive and these

912
00:46:02,000 --> 00:46:04,680
two are

913
00:46:06,319 --> 00:46:10,640
recursive so again recursive way of

914
00:46:10,640 --> 00:46:13,880
printing passing it by point or by value

915
00:46:13,880 --> 00:46:17,520
by Sorry by uh pointer by value or

916
00:46:17,520 --> 00:46:18,880
pointer by

917
00:46:18,880 --> 00:46:22,920
reference or nonrecursive

918
00:46:23,520 --> 00:46:25,800
equivalent like these are the same

919
00:46:25,800 --> 00:46:29,920
implementations but whether it's my

920
00:46:34,599 --> 00:46:38,000
value I see how this can be a Eno

921
00:46:38,000 --> 00:46:39,960
question if you want to test logic

922
00:46:39,960 --> 00:46:42,480
though not C++ see this is logic and and

923
00:46:42,480 --> 00:46:44,680
some companies will want to test both

924
00:46:44,680 --> 00:46:45,839
and then they'll say okay do you know

925
00:46:45,839 --> 00:46:49,319
C++ and how's your

926
00:46:53,160 --> 00:46:55,839
logic let's see what you guys

927
00:46:55,839 --> 00:46:58,839
answer

928
00:47:01,400 --> 00:47:06,640
A or B A or B nobody votes for except

929
00:47:06,640 --> 00:47:10,200
for all so there's people in all Camp

930
00:47:10,200 --> 00:47:11,520
they like them

931
00:47:11,520 --> 00:47:15,000
all it seems like when you

932
00:47:15,000 --> 00:47:18,000
print you don't care whether it's passed

933
00:47:18,000 --> 00:47:21,200
by value or passed by reference

934
00:47:21,200 --> 00:47:23,760
right do

935
00:47:23,760 --> 00:47:26,480
you okay here's the code so let's look

936
00:47:26,480 --> 00:47:30,520
at that I have two print functions print

937
00:47:30,520 --> 00:47:33,200
non-recursive and print recursive so I

938
00:47:33,200 --> 00:47:35,160
call them differently but that's the

939
00:47:35,160 --> 00:47:37,040
code inside remember the code was the

940
00:47:37,040 --> 00:47:40,280
same for recursive non-recursive look

941
00:47:40,280 --> 00:47:44,520
what I have I have passing by pointer by

942
00:47:44,520 --> 00:47:48,079
value in the non-recursive function and

943
00:47:48,079 --> 00:47:50,520
by reference in

944
00:47:50,520 --> 00:47:54,839
recursive so what if I

945
00:47:54,839 --> 00:47:58,400
remove in recursive function fun passing

946
00:47:58,400 --> 00:48:01,559
by reference fun nothing changes because

947
00:48:01,559 --> 00:48:04,800
you are within the function you're not

948
00:48:04,800 --> 00:48:07,160
changing that

949
00:48:07,160 --> 00:48:09,520
pointer you're just printing you're just

950
00:48:09,520 --> 00:48:12,480
looking up what's there what's the data

951
00:48:12,480 --> 00:48:14,800
and you print it out and then you call

952
00:48:14,800 --> 00:48:17,200
recursively the same function but again

953
00:48:17,200 --> 00:48:19,040
within that function there will be no

954
00:48:19,040 --> 00:48:22,119
change to which means it doesn't matter

955
00:48:22,119 --> 00:48:24,960
whether you pass that's all you save a

956
00:48:24,960 --> 00:48:28,040
little bit of uh time it's a little

957
00:48:28,040 --> 00:48:30,160
better to pass it by

958
00:48:30,160 --> 00:48:32,520
reference because then there's no copy

959
00:48:32,520 --> 00:48:34,000
Constructor

960
00:48:34,000 --> 00:48:36,599
called so

961
00:48:36,599 --> 00:48:39,200
fine copy Constructor a pointer is not a

962
00:48:39,200 --> 00:48:42,078
big deal so who

963
00:48:43,319 --> 00:48:47,280
cares well in nonrecursive

964
00:48:47,280 --> 00:48:50,920
function if I put

965
00:48:54,319 --> 00:48:57,480
reference look what it's doing it's a

966
00:48:57,480 --> 00:49:01,040
non- recursive function so it takes the

967
00:49:01,040 --> 00:49:04,000
head pointer it checks whether it's a

968
00:49:04,000 --> 00:49:06,280
null pointer or not and then it

969
00:49:06,280 --> 00:49:10,319
reassigns Head to Head nest what does it

970
00:49:10,319 --> 00:49:13,440
mean you're Lo if you passing it by

971
00:49:13,440 --> 00:49:17,640
reference you re you losing your

972
00:49:17,640 --> 00:49:20,119
data because suddenly head will look at

973
00:49:20,119 --> 00:49:23,680
him no you can't pass

974
00:49:23,680 --> 00:49:26,040
it there you go so what's the right

975
00:49:26,040 --> 00:49:28,319
answer then

976
00:49:28,319 --> 00:49:30,880
all but

977
00:49:36,839 --> 00:49:39,440
B

978
00:49:39,440 --> 00:49:44,040
okay so let's see what

979
00:49:44,680 --> 00:49:49,319
else remove front Okay so now what if I

980
00:49:49,319 --> 00:49:54,520
remove front so I want to H before this

981
00:49:54,520 --> 00:49:59,040
line looking like a list after this line

982
00:49:59,040 --> 00:50:03,440
it should look like a list with this

983
00:50:03,440 --> 00:50:06,359
memory hopefully free so hopefully there

984
00:50:06,359 --> 00:50:09,319
should be delete somewhere

985
00:50:09,319 --> 00:50:13,599
right and H should point to the H

986
00:50:13,599 --> 00:50:16,960
next so I have

987
00:50:16,960 --> 00:50:19,400
three possibilities so let me click on

988
00:50:19,400 --> 00:50:22,200
the solution right away and then go to

989
00:50:22,200 --> 00:50:25,319
your slides and you look at the code

990
00:50:25,319 --> 00:50:27,960
again passing the pointer by reference

991
00:50:27,960 --> 00:50:29,760
or by

992
00:50:29,760 --> 00:50:32,760
value and then some weird stuff

993
00:50:32,760 --> 00:50:35,720
happening there

994
00:50:35,720 --> 00:50:38,799
within the

995
00:50:38,799 --> 00:50:44,079
code like call this TMP either

996
00:50:44,079 --> 00:50:46,119
reference or

997
00:50:46,119 --> 00:50:49,119
value

998
00:50:53,000 --> 00:50:58,640
H so what should be this right solution

999
00:51:03,599 --> 00:51:06,880
C or

1000
00:51:08,400 --> 00:51:13,920
a or okay c a c a so what did I do here

1001
00:51:13,920 --> 00:51:15,160
let's go

1002
00:51:15,160 --> 00:51:17,640
look no I mean let's go just to the

1003
00:51:17,640 --> 00:51:22,960
solution we see and then we draw remove

1004
00:51:22,960 --> 00:51:27,200
front so the the possibilities were

1005
00:51:27,200 --> 00:51:29,680
of course you really know that head will

1006
00:51:29,680 --> 00:51:32,200
have to change so you probably realize

1007
00:51:32,200 --> 00:51:34,599
that if you pass it

1008
00:51:34,599 --> 00:51:37,480
by value there will be some kind of

1009
00:51:37,480 --> 00:51:38,520
problems

1010
00:51:38,520 --> 00:51:41,680
because it will not be changed head will

1011
00:51:41,680 --> 00:51:44,640
point to the same memory that you just

1012
00:51:44,640 --> 00:51:48,319
freed if you don't change it so you

1013
00:51:48,319 --> 00:51:52,440
really want to pass the pointer H where

1014
00:51:52,440 --> 00:51:54,599
is the remove

1015
00:51:54,599 --> 00:51:57,400
function um

1016
00:51:57,400 --> 00:51:59,880
remove H like H should change it should

1017
00:51:59,880 --> 00:52:01,520
point to something else so you need to

1018
00:52:01,520 --> 00:52:05,040
pass it by value by reference and

1019
00:52:05,040 --> 00:52:07,440
pointer by reference the another

1020
00:52:07,440 --> 00:52:12,799
possibility was to call this temporary

1021
00:52:12,880 --> 00:52:16,760
thing to be a reference to head again

1022
00:52:16,760 --> 00:52:19,480
and work with that why would that be a

1023
00:52:19,480 --> 00:52:21,880
problem well well let's see what happens

1024
00:52:21,880 --> 00:52:24,960
there let's see let's look at the logic

1025
00:52:24,960 --> 00:52:29,000
of the code what does it

1026
00:52:31,440 --> 00:52:35,559
do what's the logic of the code once we

1027
00:52:35,559 --> 00:52:39,280
are which one you said was it C this one

1028
00:52:39,280 --> 00:52:41,559
right yeah yeah or B so this is the

1029
00:52:41,559 --> 00:52:43,920
question mark so you

1030
00:52:43,920 --> 00:52:48,000
have head being a different name but

1031
00:52:48,000 --> 00:52:50,880
within the scope of this function for

1032
00:52:50,880 --> 00:52:55,040
each that's cool so is had a pointer a n

1033
00:52:55,040 --> 00:52:59,440
pointer no so we go side then we say TMP

1034
00:52:59,440 --> 00:53:03,599
is going to be yet another name to the

1035
00:53:03,599 --> 00:53:05,760
head it's the same

1036
00:53:05,760 --> 00:53:09,079
pointer and then you say head equals to

1037
00:53:09,079 --> 00:53:12,240
head Nest

1038
00:53:20,319 --> 00:53:23,760
so and then you delete

1039
00:53:23,760 --> 00:53:28,079
TMP you free it it's so disaster you

1040
00:53:28,079 --> 00:53:33,359
lost H six sorry you lost six and you

1041
00:53:33,359 --> 00:53:37,440
freed eight so no wonder compiler said

1042
00:53:37,440 --> 00:53:40,559
something about

1043
00:53:40,880 --> 00:53:43,520
it okay and since we have another logic

1044
00:53:43,520 --> 00:53:46,240
here we're clearing H afterwards so

1045
00:53:46,240 --> 00:53:48,280
there's a lot of problems who knows what

1046
00:53:48,280 --> 00:53:50,559
exactly complaints which order of

1047
00:53:50,559 --> 00:53:52,160
complaints it will have but there will

1048
00:53:52,160 --> 00:53:54,319
be lots of

1049
00:53:54,319 --> 00:53:57,880
complaints about because of it however

1050
00:53:57,880 --> 00:54:02,160
if you were to say temporary node so

1051
00:54:02,160 --> 00:54:06,160
let's remove all of this logic and we

1052
00:54:06,160 --> 00:54:09,400
say head is the same name for age but

1053
00:54:09,400 --> 00:54:13,000
temporary node is a different variable

1054
00:54:13,000 --> 00:54:15,520
on the stack belonging to the scope of

1055
00:54:15,520 --> 00:54:17,960
this function remove front that points

1056
00:54:17,960 --> 00:54:22,440
to six that's great because

1057
00:54:22,440 --> 00:54:26,799
now temporary the TMP holds six so you

1058
00:54:26,799 --> 00:54:30,480
can say well let's reassign head to

1059
00:54:30,480 --> 00:54:33,480
eight because you still have a handle on

1060
00:54:33,480 --> 00:54:37,280
six you didn't lose it through TMP so

1061
00:54:37,280 --> 00:54:39,160
now head really points to eight like you

1062
00:54:39,160 --> 00:54:43,440
want to and TMP hold points to sit and

1063
00:54:43,440 --> 00:54:45,400
you want to remove it you want to free

1064
00:54:45,400 --> 00:54:48,559
that and then TMP goes out of the scope

1065
00:54:48,559 --> 00:54:50,559
head goes out of the scope you're done

1066
00:54:50,559 --> 00:54:53,079
with the function remove front and in

1067
00:54:53,079 --> 00:54:55,160
the end of the day H points to eight

1068
00:54:55,160 --> 00:54:57,720
which is great

1069
00:54:57,720 --> 00:54:59,960
so that this is the correct

1070
00:54:59,960 --> 00:55:03,160
logic okay

1071
00:55:03,160 --> 00:55:06,160
cool

1072
00:55:06,559 --> 00:55:09,319
now what we've done let's look what

1073
00:55:09,319 --> 00:55:13,119
we've done so we implemented Inc front

1074
00:55:13,119 --> 00:55:16,000
remove front kind of right we could have

1075
00:55:16,000 --> 00:55:19,040
implemented remove any item but we

1076
00:55:19,040 --> 00:55:21,440
Implement remove front we printed the

1077
00:55:21,440 --> 00:55:23,920
list we printed in Reverse did we print

1078
00:55:23,920 --> 00:55:26,319
in Reverse how did I skip through print

1079
00:55:26,319 --> 00:55:28,240
print

1080
00:55:28,240 --> 00:55:31,240
reverse

1081
00:55:31,780 --> 00:55:34,599
[Music]

1082
00:55:34,599 --> 00:55:37,960
somehow how did

1083
00:55:38,160 --> 00:55:40,480
you yeah yeah yeah print function we

1084
00:55:40,480 --> 00:55:42,000
just jumped over it because I thought

1085
00:55:42,000 --> 00:55:43,559
let's do print in Reverse this is a

1086
00:55:43,559 --> 00:55:48,119
really NE and we just jumped over it

1087
00:55:48,119 --> 00:55:52,559
somehow yeah yeah yeah we jumped over it

1088
00:55:52,559 --> 00:55:54,799
so right right because yeah print

1089
00:55:54,799 --> 00:55:58,759
reverse is a really neat in

1090
00:55:59,920 --> 00:56:03,680
logic so now I I just have the code

1091
00:56:03,680 --> 00:56:05,480
right I want to print in

1092
00:56:05,480 --> 00:56:07,760
reverse and oh yeah that's why we

1093
00:56:07,760 --> 00:56:09,920
skipped because there was

1094
00:56:09,920 --> 00:56:13,319
no just just look at it and then we'll

1095
00:56:13,319 --> 00:56:14,960
jump

1096
00:56:14,960 --> 00:56:18,000
to I forgot to include the picture for

1097
00:56:18,000 --> 00:56:20,000
it and I don't know why I think I

1098
00:56:20,000 --> 00:56:21,960
included it but then I didn't refresh my

1099
00:56:21,960 --> 00:56:25,119
slides when I started the slideshow I

1100
00:56:25,119 --> 00:56:28,240
pretty sure I did it

1101
00:56:29,119 --> 00:56:31,960
H which

1102
00:56:31,960 --> 00:56:34,520
one yeah I'm pretty sure I had all of it

1103
00:56:34,520 --> 00:56:37,319
because it's it's a really neat answer

1104
00:56:37,319 --> 00:56:43,079
too I think couple of them are

1105
00:56:45,130 --> 00:56:46,599
[Music]

1106
00:56:46,599 --> 00:56:50,599
correct okay so do you think you can

1107
00:56:50,599 --> 00:56:53,839
answer which

1108
00:56:55,240 --> 00:56:58,160
one no because it's hard to see right

1109
00:56:58,160 --> 00:57:00,039
it's hard to see which one

1110
00:57:00,039 --> 00:57:02,480
a

1111
00:57:02,480 --> 00:57:05,960
okay H so what is print in

1112
00:57:05,960 --> 00:57:08,240
Reverse you would think that you just

1113
00:57:08,240 --> 00:57:11,680
take whatever function you had and just

1114
00:57:11,680 --> 00:57:14,720
swap the recursive call with the

1115
00:57:14,720 --> 00:57:18,039
printing and that would work and yes for

1116
00:57:18,039 --> 00:57:20,039
the recursive call it does work so a is

1117
00:57:20,039 --> 00:57:22,599
the correct answer and then C is the

1118
00:57:22,599 --> 00:57:25,160
correct answer

1119
00:57:25,160 --> 00:57:27,880
because it doesn't matter you're just

1120
00:57:27,880 --> 00:57:29,880
you're not changing the pointers here

1121
00:57:29,880 --> 00:57:31,880
you're just following them and printing

1122
00:57:31,880 --> 00:57:35,319
so both A and C are equivalent so the

1123
00:57:35,319 --> 00:57:37,760
question is whether this function where

1124
00:57:37,760 --> 00:57:38,920
it's not

1125
00:57:38,920 --> 00:57:42,920
recursive it passes the head

1126
00:57:42,920 --> 00:57:44,599
by

1127
00:57:44,599 --> 00:57:47,880
reference which means that this is just

1128
00:57:47,880 --> 00:57:51,400
wrong right so this is a wrong

1129
00:57:51,480 --> 00:57:53,520
function because you're going to change

1130
00:57:53,520 --> 00:57:55,319
the head while you're printing the list

1131
00:57:55,319 --> 00:57:56,680
you don't want to print

1132
00:57:56,680 --> 00:57:59,200
so B should not be correct but a and C

1133
00:57:59,200 --> 00:58:02,440
should be correct so let's look at my

1134
00:58:02,440 --> 00:58:05,039
implementation print

1135
00:58:05,039 --> 00:58:07,720
reverse yeah this is it and if you

1136
00:58:07,720 --> 00:58:09,799
remove

1137
00:58:09,799 --> 00:58:12,960
the the thing nothing changes everything

1138
00:58:12,960 --> 00:58:14,000
is

1139
00:58:14,000 --> 00:58:19,280
fine and why couldn't you do print

1140
00:58:19,280 --> 00:58:23,640
reverse for for

1141
00:58:24,039 --> 00:58:28,119
this what if you just swap

1142
00:58:38,760 --> 00:58:40,039
cannot do

1143
00:58:40,039 --> 00:58:43,240
that because then the logic is changed

1144
00:58:43,240 --> 00:58:44,079
you

1145
00:58:44,079 --> 00:58:46,799
cannot uh first go to the next element

1146
00:58:46,799 --> 00:58:48,920
and try to access it it could be a null

1147
00:58:48,920 --> 00:58:51,319
pointer so it's not that simple once you

1148
00:58:51,319 --> 00:58:54,280
have a hold on the list and you try to

1149
00:58:54,280 --> 00:58:58,039
print it in reverse without recursion

1150
00:58:58,039 --> 00:58:59,880
the logic of this W Loop has to be

1151
00:58:59,880 --> 00:59:02,200
completely changed and I didn't care to

1152
00:59:02,200 --> 00:59:03,680
think about it maybe you can think about

1153
00:59:03,680 --> 00:59:06,079
it but it's not a simple swap of the

1154
00:59:06,079 --> 00:59:09,000
operations however with recursion with

1155
00:59:09,000 --> 00:59:11,119
recursion it's really really neat that

1156
00:59:11,119 --> 00:59:14,520
you can just um let's see you can just

1157
00:59:14,520 --> 00:59:17,960
swap the recursive call with the print

1158
00:59:17,960 --> 00:59:21,000
out and then

1159
00:59:21,000 --> 00:59:23,240
um you get a

1160
00:59:23,240 --> 00:59:25,039
recursive print

1161
00:59:25,039 --> 00:59:28,440
out eight print

1162
00:59:28,440 --> 00:59:31,880
list this is print reverse oh this is

1163
00:59:31,880 --> 00:59:33,440
print recursion I'm sorry yeah yeah yeah

1164
00:59:33,440 --> 00:59:37,119
see print recursion became swapped into

1165
00:59:37,119 --> 00:59:40,680
the reverse order just because I swapped

1166
00:59:40,680 --> 00:59:45,200
the order of the recursive call so let's

1167
00:59:45,200 --> 00:59:47,960
do that recursive call and

1168
00:59:47,960 --> 00:59:51,019
[Music]

1169
00:59:51,559 --> 00:59:55,720
um and the print out so the question is

1170
00:59:55,720 --> 00:59:58,039
do you you print the head and then go to

1171
00:59:58,039 --> 01:00:01,160
the rest of the list or do you go first

1172
01:00:01,160 --> 01:00:02,720
to the rest of the list and then print

1173
01:00:02,720 --> 01:00:06,039
so in the end of the recursion you print

1174
01:00:06,039 --> 01:00:08,640
out the first element as you go out and

1175
01:00:08,640 --> 01:00:11,160
next and then so so it's really neat

1176
01:00:11,160 --> 01:00:16,559
mathematical trick exercise in logic

1177
01:00:16,559 --> 01:00:19,680
clearly and Okay so we've done

1178
01:00:19,680 --> 01:00:22,599
everything now I let me see if Elmer is

1179
01:00:22,599 --> 01:00:25,079
there because he wanted to cover your

1180
01:00:25,079 --> 01:00:26,599
lab

1181
01:00:26,599 --> 01:00:30,119
El Mar are you there yes oh cool so now

1182
01:00:30,119 --> 01:00:33,000
I can make you a oh yeah I see you I can

1183
01:00:33,000 --> 01:00:35,280
make you a co-host and the floor is

1184
01:00:35,280 --> 01:00:40,680
yours is that okay yeah that's fine

1185
01:00:42,760 --> 01:00:47,319
okay okay so that's cool you guys hear

1186
01:00:47,319 --> 01:00:49,839
well here in the in this lecture hole

1187
01:00:49,839 --> 01:00:52,520
I'll make it a little

1188
01:00:52,520 --> 01:00:57,079
louder I think she'll be her

1189
01:00:57,079 --> 01:01:00,079
well so you can start

1190
01:01:00,079 --> 01:01:02,640
presenting um

1191
01:01:02,640 --> 01:01:06,078
hello I it

1192
01:01:06,640 --> 01:01:10,280
good yeah I just have to switch uh put

1193
01:01:10,280 --> 01:01:11,880
the put the

1194
01:01:11,880 --> 01:01:14,880
zoom

1195
01:01:15,119 --> 01:01:17,280
screen

1196
01:01:17,280 --> 01:01:21,400
here then everybody will see

1197
01:01:21,400 --> 01:01:24,200
you because I'm sharing a different

1198
01:01:24,200 --> 01:01:27,280
screen than where you guys were but now

1199
01:01:27,280 --> 01:01:29,680
it's all good

1200
01:01:29,680 --> 01:01:31,559
yep

1201
01:01:31,559 --> 01:01:34,559
okay

1202
01:01:34,839 --> 01:01:38,640
uh okay so so lab inheritance is kind of

1203
01:01:38,640 --> 01:01:42,440
split into these five uh different parts

1204
01:01:42,440 --> 01:01:45,680
that that very like kind of clearly tell

1205
01:01:45,680 --> 01:01:48,960
you what you need to modify and and you

1206
01:01:48,960 --> 01:01:52,000
also have this completely uh kind of

1207
01:01:52,000 --> 01:01:53,520
separate

1208
01:01:53,520 --> 01:01:56,359
programs that that you can compile and

1209
01:01:56,359 --> 01:02:00,480
TR so I just start right away with the

1210
01:02:00,480 --> 01:02:03,000
um with the first one so I can just type

1211
01:02:03,000 --> 01:02:05,880
make test virtual if you're wondering

1212
01:02:05,880 --> 01:02:09,480
like like how does this how does this

1213
01:02:09,480 --> 01:02:12,839
work like that I can program like this

1214
01:02:12,839 --> 01:02:14,960
different I can compile this different

1215
01:02:14,960 --> 01:02:18,119
programs out of this project and uh was

1216
01:02:18,119 --> 01:02:21,039
all defined in the make file but we're

1217
01:02:21,039 --> 01:02:22,319
not going to

1218
01:02:22,319 --> 01:02:25,960
get get like uh that deep into it but if

1219
01:02:25,960 --> 01:02:30,359
you're curious then you can look from

1220
01:02:30,359 --> 01:02:32,240
there

1221
01:02:32,240 --> 01:02:37,118
um oh I do need

1222
01:02:38,039 --> 01:02:40,720
to well actually we don't need to findun

1223
01:02:40,720 --> 01:02:44,520
the ASA and version for this but compile

1224
01:02:44,520 --> 01:02:48,520
anyway I guess um anyway the point is

1225
01:02:48,520 --> 01:02:52,440
that when we first run this uh we have

1226
01:02:52,440 --> 01:02:55,680
this problem and and we can kind of see

1227
01:02:55,680 --> 01:02:59,319
uh uh what we are trying to do if we

1228
01:02:59,319 --> 01:03:02,960
open the test virtual CPP so this is the

1229
01:03:02,960 --> 01:03:04,079
main

1230
01:03:04,079 --> 01:03:07,559
program that's being FR here so the

1231
01:03:07,559 --> 01:03:10,240
situation is that we

1232
01:03:10,240 --> 01:03:11,920
have

1233
01:03:11,920 --> 01:03:15,240
um we have this

1234
01:03:15,240 --> 01:03:18,839
rectangle uh that's we have a rectangle

1235
01:03:18,839 --> 01:03:21,760
shaper uh

1236
01:03:21,760 --> 01:03:26,160
pointer uh and we're allocating this new

1237
01:03:26,160 --> 01:03:28,359
rectangle into it and then we also have

1238
01:03:28,359 --> 01:03:30,960
the shape pointer

1239
01:03:30,960 --> 01:03:33,960
and we're putting a rectangle there as

1240
01:03:33,960 --> 01:03:36,680
well so then how it's supposed to work

1241
01:03:36,680 --> 01:03:40,160
is that uh

1242
01:03:40,160 --> 01:03:43,359
this uh Noti is that okay it's it's a

1243
01:03:43,359 --> 01:03:47,000
rectangle type shape so let's use the

1244
01:03:47,000 --> 01:03:48,680
rectangle

1245
01:03:48,680 --> 01:03:52,839
functions uh but right now it doesn't it

1246
01:03:52,839 --> 01:03:56,079
doesn't know how to do that at all so

1247
01:03:56,079 --> 01:04:00,000
instead is calling the the uh shape uh

1248
01:04:00,000 --> 01:04:01,520
function so if

1249
01:04:01,520 --> 01:04:02,590
I

1250
01:04:02,590 --> 01:04:04,520
[Music]

1251
01:04:04,520 --> 01:04:07,039
um if I look

1252
01:04:07,039 --> 01:04:11,880
here the shape area and perimeter it

1253
01:04:11,880 --> 01:04:14,559
just returns zero so that's why we're

1254
01:04:14,559 --> 01:04:16,039
getting zero here it's calling these

1255
01:04:16,039 --> 01:04:17,400
functions and these

1256
01:04:17,400 --> 01:04:20,400
are these are not

1257
01:04:20,400 --> 01:04:23,200
good

1258
01:04:23,200 --> 01:04:28,200
um instead we would wanted to to use the

1259
01:04:28,200 --> 01:04:30,960
rectangle functions

1260
01:04:30,960 --> 01:04:33,559
and yeah we can see here the rectangle

1261
01:04:33,559 --> 01:04:35,079
has these defined but these are not

1262
01:04:35,079 --> 01:04:39,839
getting called uh so the solution to

1263
01:04:39,839 --> 01:04:42,520
this

1264
01:04:43,200 --> 01:04:47,760
problem is to make these functions

1265
01:04:47,760 --> 01:04:50,200
virtual so these are the ones that we're

1266
01:04:50,200 --> 01:04:51,319
using

1267
01:04:51,319 --> 01:04:54,720
so writing this virtual keyword here

1268
01:04:54,720 --> 01:04:56,440
means that

1269
01:04:56,440 --> 01:04:58,279
uh it's going to

1270
01:04:58,279 --> 01:05:02,000
dynamically uh see what the right

1271
01:05:02,000 --> 01:05:08,079
function to call is for these derived

1272
01:05:08,160 --> 01:05:11,880
objects uh okay so

1273
01:05:11,880 --> 01:05:16,039
let's let's make again okay and now you

1274
01:05:16,039 --> 01:05:18,119
can see that everything's working

1275
01:05:18,119 --> 01:05:22,520
correctly so even though one pointer is

1276
01:05:22,520 --> 01:05:24,119
is a shape pointer and one is a

1277
01:05:24,119 --> 01:05:28,039
rectangle pointer but both of them

1278
01:05:28,039 --> 01:05:31,119
uh point to the same thing because of

1279
01:05:31,119 --> 01:05:34,319
the virtual

1280
01:05:34,720 --> 01:05:36,359
keyword

1281
01:05:36,359 --> 01:05:42,359
okay uh then move on to the next

1282
01:05:42,359 --> 01:05:46,599
part um so let's just make

1283
01:05:46,599 --> 01:05:52,279
the test Destructor as a

1284
01:05:53,000 --> 01:05:56,960
n because we're troubleshooting this

1285
01:05:56,960 --> 01:06:01,119
memory issue here so we're seeing a new

1286
01:06:01,119 --> 01:06:04,119
delay type

1287
01:06:04,119 --> 01:06:08,000
mismatch uh so then this seems to again

1288
01:06:08,000 --> 01:06:12,440
be a problem where uh the

1289
01:06:12,440 --> 01:06:14,920
correct function is not getting called

1290
01:06:14,920 --> 01:06:15,640
this

1291
01:06:15,640 --> 01:06:18,880
time this time it's um Destructor but

1292
01:06:18,880 --> 01:06:22,160
it's the same idea so so the

1293
01:06:22,160 --> 01:06:25,599
triangle uh it has this Destructor here

1294
01:06:25,599 --> 01:06:27,720
but this is not actually getting called

1295
01:06:27,720 --> 01:06:30,359
right now

1296
01:06:30,359 --> 01:06:34,960
um okay so we should look at shape

1297
01:06:34,960 --> 01:06:36,839
and

1298
01:06:36,839 --> 01:06:41,160
trable uh it says uh here on the

1299
01:06:41,160 --> 01:06:43,319
exercise page which files you need to

1300
01:06:43,319 --> 01:06:46,559
modify so it'll make it a little

1301
01:06:46,559 --> 01:06:50,240
easier uh for you to find what the fix

1302
01:06:50,240 --> 01:06:53,879
so so we also make the

1303
01:06:54,319 --> 01:06:56,160
destructor um

1304
01:06:56,160 --> 01:06:59,200
oh not that

1305
01:06:59,599 --> 01:07:03,119
one yeah let's also make the destructor

1306
01:07:03,119 --> 01:07:07,160
virtual so that's the same idea as the

1307
01:07:07,160 --> 01:07:09,440
uh previous

1308
01:07:09,440 --> 01:07:12,440
case

1309
01:07:16,119 --> 01:07:19,279
where I'm sorry I can't really hear you

1310
01:07:19,279 --> 01:07:22,200
from there El I just wanted to say that

1311
01:07:22,200 --> 01:07:24,760
so far to fix this two problems we had

1312
01:07:24,760 --> 01:07:28,960
to add the three words virtual in

1313
01:07:28,960 --> 01:07:31,680
places yeah pretty much mentally it

1314
01:07:31,680 --> 01:07:34,240
really changes the picture because it

1315
01:07:34,240 --> 01:07:37,000
changes from static binding to Dynamic

1316
01:07:37,000 --> 01:07:38,319
binding

1317
01:07:38,319 --> 01:07:41,839
right yeah if you're doing inheritance

1318
01:07:41,839 --> 01:07:47,520
then uh then virtual is a very uh a very

1319
01:07:47,520 --> 01:07:50,520
important keyword and you need to use it

1320
01:07:50,520 --> 01:07:52,000
most of the time when you're when you're

1321
01:07:52,000 --> 01:07:54,200
using

1322
01:07:54,200 --> 01:07:57,079
inheritance uh

1323
01:07:57,079 --> 01:07:58,440
but but of course you always want to

1324
01:07:58,440 --> 01:08:00,880
think about like like is this supposed

1325
01:08:00,880 --> 01:08:04,160
to be virtual or not so so don't just

1326
01:08:04,160 --> 01:08:06,760
like by default put it on

1327
01:08:06,760 --> 01:08:08,960
everything

1328
01:08:08,960 --> 01:08:13,079
um okay let's see what the next one is

1329
01:08:13,079 --> 01:08:17,319
so if we compile

1330
01:08:17,479 --> 01:08:21,040
this test

1331
01:08:21,040 --> 01:08:23,000
Constructor uh

1332
01:08:23,000 --> 01:08:27,040
then we can see that the C CES the the

1333
01:08:27,040 --> 01:08:28,759
circle is not getting

1334
01:08:28,759 --> 01:08:31,479
constructed uh correctly so so we should

1335
01:08:31,479 --> 01:08:36,559
look at Circle CP it says

1336
01:08:37,279 --> 01:08:40,238
here okay let's look at this Constructor

1337
01:08:40,238 --> 01:08:43,679
and uh actually what what the problem

1338
01:08:43,679 --> 01:08:47,600
here is we we can we can kind of see see

1339
01:08:47,600 --> 01:08:51,198
clearly that it's taking us argument uh

1340
01:08:51,198 --> 01:08:53,399
P Center and P

1341
01:08:53,399 --> 01:08:56,479
color but they're not actually being

1342
01:08:56,479 --> 01:08:59,640
used for anything so we need to figure

1343
01:08:59,640 --> 01:09:05,440
out how how we can um

1344
01:09:06,198 --> 01:09:10,158
initialize the circle

1345
01:09:10,719 --> 01:09:16,600
correctly uh okay so if

1346
01:09:18,040 --> 01:09:21,479
we if we look at Circle H we can notice

1347
01:09:21,479 --> 01:09:24,279
that okay well actually the the center

1348
01:09:24,279 --> 01:09:28,238
and color are are not defined

1349
01:09:28,238 --> 01:09:29,960
here

1350
01:09:29,960 --> 01:09:33,560
uh but then this inerts

1351
01:09:33,560 --> 01:09:36,920
shape and and let's let's check

1352
01:09:36,920 --> 01:09:39,880
this uh okay so here we are there's the

1353
01:09:39,880 --> 01:09:42,520
center and there's color and there's

1354
01:09:42,520 --> 01:09:44,960
also a Constructor for

1355
01:09:44,960 --> 01:09:49,000
this so then what we can do is use that

1356
01:09:49,000 --> 01:09:52,479
Constructor that's defined

1357
01:09:54,320 --> 01:09:57,320
there

1358
01:09:57,760 --> 01:10:02,280
in this in initialization

1359
01:10:03,000 --> 01:10:06,679
list let's try this okay and everything

1360
01:10:06,679 --> 01:10:10,520
is correct so so what happens here is

1361
01:10:10,520 --> 01:10:14,600
that uh we initialize the properties of

1362
01:10:14,600 --> 01:10:18,480
the of the base class in this

1363
01:10:18,480 --> 01:10:20,280
Constructor and this has to happen in

1364
01:10:20,280 --> 01:10:21,840
the

1365
01:10:21,840 --> 01:10:24,320
initialization uh list because

1366
01:10:24,320 --> 01:10:29,040
Constructors are only run during

1367
01:10:29,040 --> 01:10:31,520
initialization that you can't like

1368
01:10:31,520 --> 01:10:34,880
manually call them later so so we need

1369
01:10:34,880 --> 01:10:37,480
to set up the properties of the base

1370
01:10:37,480 --> 01:10:38,560
class

1371
01:10:38,560 --> 01:10:41,840
first and then we set up the property of

1372
01:10:41,840 --> 01:10:45,320
the of the circle class and that way we

1373
01:10:45,320 --> 01:10:48,360
can handle this

1374
01:10:50,199 --> 01:10:53,719
situation okay

1375
01:10:54,239 --> 01:10:57,239
next

1376
01:10:57,760 --> 01:11:01,400
let's compile pure virtual except that

1377
01:11:01,400 --> 01:11:06,360
it does not compile it says abstract

1378
01:11:06,360 --> 01:11:07,880
class type

1379
01:11:07,880 --> 01:11:09,960
truck

1380
01:11:09,960 --> 01:11:13,400
so so we're we're trying to we're trying

1381
01:11:13,400 --> 01:11:16,480
to create a new truck but the compiler

1382
01:11:16,480 --> 01:11:19,360
is saying that this class is abstract so

1383
01:11:19,360 --> 01:11:20,679
we can't do

1384
01:11:20,679 --> 01:11:26,320
that uh so then why why is it

1385
01:11:26,320 --> 01:11:29,920
abstract so let's

1386
01:11:29,920 --> 01:11:34,760
um oh that's not how I wanted this to

1387
01:11:34,760 --> 01:11:37,000
work um

1388
01:11:37,000 --> 01:11:40,840
okay all these files

1389
01:11:42,040 --> 01:11:46,880
here so so let's see that so if if you

1390
01:11:46,880 --> 01:11:49,600
remember from The Inheritance lecture uh

1391
01:11:49,600 --> 01:11:54,120
we have that way of uh the declaring

1392
01:11:54,120 --> 01:11:57,360
this uh pure

1393
01:11:57,360 --> 01:12:01,639
virtual uh methods

1394
01:12:02,600 --> 01:12:06,520
like like if if we do like equal zero

1395
01:12:06,520 --> 01:12:08,679
like that but but we don't see any of

1396
01:12:08,679 --> 01:12:13,320
that here and then if we look in the CPP

1397
01:12:13,320 --> 01:12:15,600
file uh we can see that we have all

1398
01:12:15,600 --> 01:12:17,280
these functions

1399
01:12:17,280 --> 01:12:20,639
implemented uh but in this

1400
01:12:20,639 --> 01:12:23,639
case

1401
01:12:24,159 --> 01:12:28,199
um wait that's that's not the

1402
01:12:29,000 --> 01:12:32,239
truck skip the corrected file okay that

1403
01:12:32,239 --> 01:12:35,120
makes more sense

1404
01:12:35,120 --> 01:12:37,840
uh yeah yeah we don't we don't we don't

1405
01:12:37,840 --> 01:12:40,040
see any like pure virtual uh

1406
01:12:40,040 --> 01:12:43,679
declarations here but

1407
01:12:43,679 --> 01:12:47,920
um but the problem that we have here is

1408
01:12:47,920 --> 01:12:51,000
that there's a function missing from

1409
01:12:51,000 --> 01:12:56,000
here that's defined in the drawable

1410
01:12:56,000 --> 01:12:59,239
class uh so let's look

1411
01:12:59,239 --> 01:13:02,920
here virtual void draw so this is a p

1412
01:13:02,920 --> 01:13:06,159
pure virtual function and and then we

1413
01:13:06,159 --> 01:13:08,719
want truck to be something that we

1414
01:13:08,719 --> 01:13:12,320
can uh we can actually create instances

1415
01:13:12,320 --> 01:13:16,520
of of truck but it doesn't actually have

1416
01:13:16,520 --> 01:13:19,719
the draw function here and and in the

1417
01:13:19,719 --> 01:13:22,400
base class it's defined as pure virtual

1418
01:13:22,400 --> 01:13:26,239
so so that also makes this class

1419
01:13:26,239 --> 01:13:33,320
abstract and we need to fix that so

1420
01:13:34,679 --> 01:13:39,600
essentially uh we just need to Define

1421
01:13:41,040 --> 01:13:44,560
this entire

1422
01:13:45,639 --> 01:13:49,560
thing okay so now it's

1423
01:13:52,320 --> 01:13:53,880
there

1424
01:13:53,880 --> 01:13:59,199
start uh um typing it

1425
01:14:02,080 --> 01:14:05,199
here okay so let's try if we if we just

1426
01:14:05,199 --> 01:14:07,480
try to compile it

1427
01:14:07,480 --> 01:14:12,199
now uh that's this

1428
01:14:14,000 --> 01:14:18,280
fine hold on did I do something

1429
01:14:24,040 --> 01:14:27,040
wrong

1430
01:14:42,360 --> 01:14:45,600
okay now I'm not really sure

1431
01:14:45,600 --> 01:14:49,199
what what I did wrong why is this uh

1432
01:14:49,199 --> 01:14:53,639
what is say not much what did it say not

1433
01:14:53,639 --> 01:14:56,719
mat no declaration

1434
01:14:56,719 --> 01:14:59,719
matches

1435
01:15:02,760 --> 01:15:06,480
um I all the like draw functions for all

1436
01:15:06,480 --> 01:15:09,920
the components inside this draw function

1437
01:15:09,920 --> 01:15:12,159
that

1438
01:15:13,000 --> 01:15:17,000
is so when I did it what I had to do is

1439
01:15:17,000 --> 01:15:20,080
inside this draw I needed to basically F

1440
01:15:20,080 --> 01:15:24,840
that the there um they have a l top of

1441
01:15:24,840 --> 01:15:27,679
that so I need to add all the functions

1442
01:15:27,679 --> 01:15:31,159
like all the components the engine the

1443
01:15:31,159 --> 01:15:34,690
wheel oh no no it

1444
01:15:34,690 --> 01:15:35,960
[Music]

1445
01:15:35,960 --> 01:15:39,800
does yeah I did it like

1446
01:15:40,199 --> 01:15:42,800
this why

1447
01:15:42,800 --> 01:15:45,920
comp yeah yeah it should have it should

1448
01:15:45,920 --> 01:15:48,159
have compiled I don't really understand

1449
01:15:48,159 --> 01:15:50,880
what what I missed

1450
01:15:50,880 --> 01:15:56,920
here problem so I don't understand

1451
01:16:05,000 --> 01:16:07,800
it should compile

1452
01:16:11,920 --> 01:16:15,719
without oh right

1453
01:16:19,239 --> 01:16:21,520
maybe

1454
01:16:21,520 --> 01:16:23,920
missing

1455
01:16:23,920 --> 01:16:26,360
oh

1456
01:16:26,360 --> 01:16:27,800
yeah good

1457
01:16:27,800 --> 01:16:29,400
job

1458
01:16:29,400 --> 01:16:33,800
okay that's that's what forgetting one

1459
01:16:33,800 --> 01:16:35,920
word does to

1460
01:16:35,920 --> 01:16:39,120
you that's true though but I'm sure that

1461
01:16:39,120 --> 01:16:41,760
you can

1462
01:16:41,880 --> 01:16:45,159
see oh sometimes it tells you which

1463
01:16:45,159 --> 01:16:49,040
which are the candidates but not in

1464
01:16:49,040 --> 01:16:52,000
this okay so let's let's look at the

1465
01:16:52,000 --> 01:16:54,040
output for this one so we need to make

1466
01:16:54,040 --> 01:16:55,679
sure that it's

1467
01:16:55,679 --> 01:16:58,199
uh correct so

1468
01:16:58,199 --> 01:17:01,759
test uh pure

1469
01:17:04,679 --> 01:17:09,320
virtual and we have a truck like that

1470
01:17:09,320 --> 01:17:13,880
and let's compare to the

1471
01:17:14,639 --> 01:17:16,920
solution

1472
01:17:16,920 --> 01:17:20,360
um yeah it looks like it's the same so

1473
01:17:20,360 --> 01:17:24,199
uh you do need to make sure that the uh

1474
01:17:24,199 --> 01:17:27,360
draw order is correct that that the

1475
01:17:27,360 --> 01:17:30,800
wheels are drawn like after the other

1476
01:17:30,800 --> 01:17:33,280
things and the window is drawn like

1477
01:17:33,280 --> 01:17:35,880
after the

1478
01:17:37,560 --> 01:17:41,480
part this is per I feel like it's a

1479
01:17:41,480 --> 01:17:46,120
really good piece of exercise and make

1480
01:17:46,120 --> 01:17:49,239
tutorial really nice

1481
01:17:49,239 --> 01:17:53,960
exercise okay so so we managed to get

1482
01:17:53,960 --> 01:17:56,760
that fixed so of course a very very

1483
01:17:56,760 --> 01:17:59,280
integral part of the class was missing

1484
01:17:59,280 --> 01:18:03,040
the the uh draw function and after that

1485
01:18:03,040 --> 01:18:07,600
got defined then then it was no longer

1486
01:18:07,600 --> 01:18:10,719
um abstract and I I'll

1487
01:18:10,719 --> 01:18:14,560
just I'll just going to show now that uh

1488
01:18:14,560 --> 01:18:16,880
even even if this function doesn't do

1489
01:18:16,880 --> 01:18:19,920
anything uh it's still counts as like

1490
01:18:19,920 --> 01:18:22,480
being this function being defined and

1491
01:18:22,480 --> 01:18:26,759
and that way it's not abstract anymore

1492
01:18:27,810 --> 01:18:30,960
[Music]

1493
01:18:30,960 --> 01:18:34,840
yeah okay uh one

1494
01:18:34,840 --> 01:18:39,679
more make test

1495
01:18:44,280 --> 01:18:47,760
slicing okay I know I know some of you

1496
01:18:47,760 --> 01:18:49,520
had like a problem

1497
01:18:49,520 --> 01:18:52,760
where uh it wouldn't compile here and

1498
01:18:52,760 --> 01:18:55,920
that might depend on uh

1499
01:18:55,920 --> 01:18:56,960
what

1500
01:18:56,960 --> 01:19:02,239
you did in the previous Parts but right

1501
01:19:02,239 --> 01:19:06,280
now if we go look at

1502
01:19:06,280 --> 01:19:10,239
the uh okay where's the inest sizing

1503
01:19:10,239 --> 01:19:13,520
here so so what it tries to do here is

1504
01:19:13,520 --> 01:19:17,239
create this drawable

1505
01:19:17,480 --> 01:19:20,600
flower uh and then then just draw that

1506
01:19:20,600 --> 01:19:23,719
and then if we look

1507
01:19:23,719 --> 01:19:26,719
at

1508
01:19:28,120 --> 01:19:32,159
uh the the flower class

1509
01:19:32,159 --> 01:19:35,760
here then it has these uh

1510
01:19:35,760 --> 01:19:37,639
shapes

1511
01:19:37,639 --> 01:19:41,320
uh declared here and and the way these

1512
01:19:41,320 --> 01:19:45,120
are declared is that the shape class

1513
01:19:45,120 --> 01:19:48,320
needs to not be abstract for this to

1514
01:19:48,320 --> 01:19:51,239
work because because here we're actually

1515
01:19:51,239 --> 01:19:55,360
like creating new instances of of shape

1516
01:19:55,360 --> 01:19:59,520
and if you if you made shape abstract

1517
01:19:59,520 --> 01:20:03,639
which it could as well be that's that's

1518
01:20:03,639 --> 01:20:04,960
not

1519
01:20:04,960 --> 01:20:07,320
really at least here we're not like

1520
01:20:07,320 --> 01:20:09,080
using shapes by

1521
01:20:09,080 --> 01:20:13,040
themselves uh it's always like meant to

1522
01:20:13,040 --> 01:20:15,800
be inherited so in that case it could be

1523
01:20:15,800 --> 01:20:19,719
abstract but uh but then if it is

1524
01:20:19,719 --> 01:20:22,400
abstract then the compiler would already

1525
01:20:22,400 --> 01:20:25,239
tell you that we can't do this

1526
01:20:25,239 --> 01:20:30,919
uh but right now we can uh

1527
01:20:31,080 --> 01:20:34,080
however

1528
01:20:34,320 --> 01:20:36,719
um yeah if we look at the output this

1529
01:20:36,719 --> 01:20:38,360
doesn't look much like a

1530
01:20:38,360 --> 01:20:41,120
flower uh at

1531
01:20:41,120 --> 01:20:45,800
all uh and the problem is that's a

1532
01:20:45,800 --> 01:20:49,239
problem we had to deal with uh before as

1533
01:20:49,239 --> 01:20:53,280
well where we're creating these

1534
01:20:53,280 --> 01:20:55,280
local copies

1535
01:20:55,280 --> 01:20:57,440
uh in the

1536
01:20:57,440 --> 01:21:01,239
stack and and then we're just like

1537
01:21:01,239 --> 01:21:05,880
trying to save those but the way we need

1538
01:21:05,880 --> 01:21:10,840
to make this work is by using pointers

1539
01:21:10,840 --> 01:21:14,400
so we can actually uh retain everything

1540
01:21:14,400 --> 01:21:16,759
in the

1541
01:21:18,800 --> 01:21:23,400
Heap it's really this is a cool B you

1542
01:21:23,400 --> 01:21:26,559
really need to understand

1543
01:21:26,800 --> 01:21:29,159
and this way we can

1544
01:21:29,159 --> 01:21:33,280
also also just kind of

1545
01:21:36,120 --> 01:21:39,239
um hold

1546
01:21:47,360 --> 01:21:51,040
on the stem

1547
01:21:51,040 --> 01:21:53,639
is I think it should be like rectangle

1548
01:21:53,639 --> 01:21:56,520
and then inside

1549
01:22:00,199 --> 01:22:02,400
oh oh yeah it's a it's a new rectangle

1550
01:22:02,400 --> 01:22:06,000
yeah yeah that's what it is um okay so

1551
01:22:06,000 --> 01:22:07,679
stack variables will have to be

1552
01:22:07,679 --> 01:22:09,719
statically the compiler will need to

1553
01:22:09,719 --> 01:22:12,159
know which functions to call but if it's

1554
01:22:12,159 --> 01:22:15,280
a dynamic if it's a heat variable then

1555
01:22:15,280 --> 01:22:17,960
it okay so so that's going to be a

1556
01:22:17,960 --> 01:22:21,520
rectangle and this going to be a

1557
01:22:21,520 --> 01:22:23,520
circle

1558
01:22:23,520 --> 01:22:26,520
uh

1559
01:22:35,040 --> 01:22:38,199
and then a

1560
01:22:42,800 --> 01:22:46,199
triangle Al so we don't we don't need

1561
01:22:46,199 --> 01:22:50,920
to use those like temporary copies at

1562
01:22:50,920 --> 01:22:54,800
all here we can just uh oh double

1563
01:22:54,800 --> 01:22:57,600
semicolons here not that I caused any

1564
01:22:57,600 --> 01:23:02,320
problems but um yeah we can just do this

1565
01:23:02,320 --> 01:23:06,320
directly of course now we also need

1566
01:23:06,320 --> 01:23:10,080
to change these to

1567
01:23:10,080 --> 01:23:11,760
be

1568
01:23:11,760 --> 01:23:15,760
um act act as pointers as well okay

1569
01:23:15,760 --> 01:23:18,719
what's this everything no there's still

1570
01:23:18,719 --> 01:23:20,880
pistal

1571
01:23:20,880 --> 01:23:23,440
Center which is

1572
01:23:23,440 --> 01:23:26,440
on

1573
01:23:26,639 --> 01:23:29,000
over

1574
01:23:30,040 --> 01:23:32,920
here let's see if this is fine

1575
01:23:32,920 --> 01:23:36,840
now yeah that looks like a

1576
01:23:37,199 --> 01:23:40,520
flower okay good so

1577
01:23:40,520 --> 01:23:45,320
then that was all of them so I guess at

1578
01:23:45,320 --> 01:23:48,560
this point uh if you have any questions

1579
01:23:48,560 --> 01:23:52,040
about this assignment let me

1580
01:23:52,040 --> 01:23:56,239
know so this is pretty cool thank you El

1581
01:23:56,239 --> 01:23:57,159
really

1582
01:23:57,159 --> 01:24:00,040
cool um yeah so all of this is

1583
01:24:00,040 --> 01:24:02,679
essentially making sure that

1584
01:24:02,679 --> 01:24:07,080
virtual um functions bind to proper he

1585
01:24:07,080 --> 01:24:08,920
variables that's that's all this

1586
01:24:08,920 --> 01:24:11,440
assignment is about

1587
01:24:11,440 --> 01:24:15,920
right um okay so oh perfect timing thank

1588
01:24:15,920 --> 01:24:18,679
you El what I wanted to finish it off oh

1589
01:24:18,679 --> 01:24:21,000
yeah now you have everything you need to

1590
01:24:21,000 --> 01:24:25,440
uh to finish lab GDB which is about link

1591
01:24:25,440 --> 01:24:29,600
lists and GDB which is useful tool that

1592
01:24:29,600 --> 01:24:31,600
you can use now for for the rest of the

1593
01:24:31,600 --> 01:24:34,880
sence and MP lists you can finish all of

1594
01:24:34,880 --> 01:24:36,320
them

1595
01:24:36,320 --> 01:24:38,520
now next time we'll talk about hash

1596
01:24:38,520 --> 01:24:40,920
table so that you can do la lab

1597
01:24:40,920 --> 01:24:43,320
dictionary and lab

1598
01:24:43,320 --> 01:24:45,960
hash and we'll be done and after that

1599
01:24:45,960 --> 01:24:48,040
next week please remember it's mostly

1600
01:24:48,040 --> 01:24:50,560
just about

1601
01:24:50,840 --> 01:24:57,119
P okay I'll see you guys then on

1602
01:24:57,679 --> 01:25:00,760
Thursday I hope I recorded did I record

1603
01:25:00,760 --> 01:25:04,239
this lecture yeah it seems like you

1604
01:25:04,239 --> 01:25:06,800
still have recording on yeah thank

1605
01:25:06,800 --> 01:25:09,880
goodness I'm not thinking straight

1606
01:25:09,880 --> 01:25:13,400
today okay I'll see you thank you El bye

1607
01:25:13,400 --> 01:25:17,119
all right see you

